<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<!-- 제품수급 > 일별 제품수급 Simul -->
<mapper namespace="com.hitejinro.snop.work.dao.M02020DaoMapper">
    
    <!-- 데이터 조회 -->
    <select id="search" parameterType="map" resultType="map">
    SELECT /* com.hitejinro.snop.work.dao.M02020DaoMapper.search */
           A.VER_CD
         , A.VER_NM, A.VER_DESC
         , A.STD_YYYYMMDD, TO_CHAR(TO_DATE(A.STD_YYYYMMDD, 'YYYYMMDD'), 'YYYY-MM') AS STD_YYYYMM
         , A.USE_YN
         , A.VER_FR_DT, A.VER_TO_DT
         , TO_CHAR(A.WORK_DT_10, 'YYYY-MM-DD HH24:MI:SS') || ' ' || NVL(BA.USER_NM, A.WORK_USER_10) AS WORK_INFO_10
         , TO_CHAR(A.WORK_DT_20, 'YYYY-MM-DD HH24:MI:SS') || ' ' || NVL(BB.USER_NM, A.WORK_USER_20) AS WORK_INFO_20
         
         /*
         , TO_CHAR(A.WORK_DT_10, 'YYYY-MM-DD HH24:MI:SS') AS WORK_DT_10, A.WORK_USER_10, BA.USER_NM AS WORK_USER_10_NM
         , TO_CHAR(A.WORK_DT_20, 'YYYY-MM-DD HH24:MI:SS') AS WORK_DT_20, A.WORK_USER_20, BB.USER_NM AS WORK_USER_20_NM
         , A.PRDT_VAR_VER_CD
         */
      FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_M A
 LEFT JOIN SCMU.W_SOP_TB_USER_M           BA
        ON BA.USER_ID = A.WORK_USER_10
 LEFT JOIN SCMU.W_SOP_TB_USER_M           BB
        ON BB.USER_ID = A.WORK_USER_20
     WHERE 1 = 1
       AND A.STD_YYYYMMDD LIKE #{bssYYYYMM, jdbcType=VARCHAR} || '__'
       AND (
                (#{useYn, jdbcType=VARCHAR} = '!ALL' AND 1 = 1)
                OR
                (#{useYn, jdbcType=VARCHAR} = A.USE_YN)
           )
     ORDER BY A.STD_YYYYMMDD DESC, A.VER_CD DESC
    </select>

    <!-- 신규 버전코드 조회 -->
    <select id="selectNewVerCd" parameterType="map" resultType="map">
SELECT /* com.hitejinro.snop.work.dao.M02020DaoMapper.selectNewVerCd */
       NVL2(MAX(VER_CD)
            , #{STD_YYYYMMDD, jdbcType=VARCHAR} || '-' || LPAD((TO_NUMBER(SUBSTR(MAX(VER_CD), 10))+1), 3, '0')
            , #{STD_YYYYMMDD, jdbcType=VARCHAR} || '-001') AS NEW_VER_CD -- 기준일자+일련번호 3자리. ex) 20210719-001
  FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_M
 WHERE 1 = 1
   AND STD_YYYYMMDD = #{STD_YYYYMMDD, jdbcType=VARCHAR}
    </select>

    
    <!-- 데이터 저장 : 추가 -->
    <update id="insert" parameterType="map">
INSERT /* com.hitejinro.snop.work.dao.M02020DaoMapper.insert */
  INTO SCMU.W_SOP_TB_DALY_SCM_SIMUL_M
       (VER_CD
        , VER_NM, VER_DESC, STD_YYYYMMDD, USE_YN, VER_FR_DT, VER_TO_DT
        , WORK_DT_10, WORK_USER_10, WORK_DT_20, WORK_USER_20, PRDT_VAR_VER_CD
        , ATTRIBUTE1, ATTRIBUTE2, ATTRIBUTE3, ATTRIBUTE4, ATTRIBUTE5
        , CREATED_BY, CREATION_DATE, LAST_UPDATED_BY, LAST_UPDATE_DATE)
VALUES (#{NEW_VER_CD, jdbcType=VARCHAR}
        , #{VER_NM, jdbcType=VARCHAR}, #{VER_DESC, jdbcType=VARCHAR}, #{STD_YYYYMMDD, jdbcType=VARCHAR}, #{USE_YN, jdbcType=VARCHAR}, #{VER_FR_DT, jdbcType=VARCHAR}, #{VER_TO_DT, jdbcType=VARCHAR}
        , NULL, NULL, NULL, NULL, NULL
        , NULL, NULL, NULL, NULL, NULL
        , #{userId, jdbcType=VARCHAR}, SYSDATE, #{userId, jdbcType=VARCHAR}, SYSDATE)
    </update>
    
    <!-- 데이터 저장 : 수정 -->
    <update id="update" parameterType="map">
UPDATE /* com.hitejinro.snop.work.dao.M02020DaoMapper.update */
       SCMU.W_SOP_TB_DALY_SCM_SIMUL_M T
       -- 기준일자(STD_YYYYMMDD), 시작일자(VER_FR_DT)는 변경 불가
   SET T.VER_NM             = #{VER_NM, jdbcType=VARCHAR}
     , T.VER_DESC           = #{VER_DESC, jdbcType=VARCHAR}
     , T.USE_YN             = #{USE_YN, jdbcType=VARCHAR}
     , T.VER_TO_DT          = #{VER_TO_DT, jdbcType=VARCHAR}
     , T.LAST_UPDATED_BY    = #{userId, jdbcType=VARCHAR}
     , T.LAST_UPDATE_DATE   = SYSDATE
 WHERE 1 = 1
   AND T.VER_CD = #{VER_CD, jdbcType=VARCHAR}
    </update>
    
    <!-- 판매설정 - 요일별판매비율 데이터 저장 : 버전 생성시, 기준일자(실적) 포함 20일간의 평균으로 계산 -->
    <update id="updateSaleSetDowSaleRate" parameterType="map">
MERGE /* com.hitejinro.snop.work.dao.M02020DaoMapper.updateSaleSetDowSaleRate */
 INTO SCMU.W_SOP_TB_DALY_SCM_SIMUL_SALE_SET_M T
USING (
            SELECT VER_CD, LIQUOR_CODE
                 , 'DOW_SALE_RATE' AS SALE_SET_TYPE_CODE
                 , ROW_NUMBER() OVER (PARTITION BY VER_CD, LIQUOR_CODE ORDER BY DAY_OF_WEEK) AS SEQNO
                 , TRIM(TO_CHAR(
                                   CASE WHEN TOTAL_SALE_QTY = 0 THEN 0
                                        ELSE ROUND(SALE_QTY / TOTAL_SALE_QTY, 3)
                                             -- 반올림에 따른 단수차이를 가장 큰 값에 보정
                                             + CASE WHEN ROW_NUMBER() OVER (PARTITION BY VER_CD, LIQUOR_CODE ORDER BY SALE_QTY DESC) = 1 THEN 1 - SUM(ROUND(SALE_QTY / TOTAL_SALE_QTY, 3)) OVER (PARTITION BY VER_CD, LIQUOR_CODE)
                                                    ELSE 0
                                               END
                                   END
                                , '990.999')) AS VAL -- 다양한 값을 사용하기 위해서, 문자형으로 변환해서 처리
                 , DOW_CODE
                 , NULL AS USE_SALE_QTY_YYYYMM, NULL AS SALE_VAR_APL_FR_DT, NULL AS SALE_VAR_APL_TO_DT, NULL AS SALE_VAR_NAME, NULL AS SALE_VAR_TYPE, NULL AS SALE_VAR_USAGE_CODE, NULL AS SALE_VAR_ITEM_CODE, NULL AS RMKS
                 , NULL AS ATTRIBUTE1, NULL AS ATTRIBUTE2, NULL AS ATTRIBUTE3, NULL AS ATTRIBUTE4, NULL AS ATTRIBUTE5
                 
              FROM (
                        SELECT VER_CD, LIQUOR_CODE, DOW_CODE, DAY_OF_WEEK, SALE_QTY
                             , SUM(NVL(SALE_QTY, 0)) OVER (PARTITION BY VER_CD, LIQUOR_CODE) AS TOTAL_SALE_QTY
                          FROM (
                                    SELECT A.VER_CD, A.STD_YYYYMMDD
                                         , B.BF_20D_YYYYMMDD    -- 기준일자(실적) 기준으로 최근 20일 이전 일자(기준일자 포함)
                                         , D.LIQUOR_CODE, C.DOW_CODE, C.DAY_OF_WEEK
                                         , SUM(NVL(D.ACTUAL_SALE_QTY * D.UOM_CONVERSION_VALUE, 0)) AS SALE_QTY
                                      FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_M A
                                      JOIN SCMU.W_SOP_VW_CALENDAR_M       B
                                        ON B.YYYYMMDD = TO_CHAR(TO_DATE(A.STD_YYYYMMDD, 'YYYYMMDD')+1, 'YYYYMMDD')
                                CROSS JOIN (
                                                SELECT CODE AS DOW_CODE, NAME AS DOW_NAME, SEGMENT2 AS DAY_OF_WEEK
                                                  FROM SCMU.W_SOP_TB_COM_CODE_M
                                                 WHERE 1 = 1
                                                   AND GROUP_CODE = 'DOW_CODE'
                                                   AND USE_YN     = 'Y'
                                                   AND SEGMENT2   IN ('2', '3', '4', '5', '6') -- 요일(일=1, 토=7) : 주중만 사용
                                           )                              C
                                 LEFT JOIN SCMU.M_SOP_TB_ITEM_SALE_F      D
                                        ON D.PERIOD_YYYYMMDD BETWEEN B.BF_20D_YYYYMMDD AND A.STD_YYYYMMDD
                                       AND TO_CHAR(TO_DATE(D.PERIOD_YYYYMMDD, 'YYYYMMDD'), 'D') = C.DAY_OF_WEEK
                                       AND D.ITEM_TYPE       = 'FG'
                                       AND D.LIQUOR_CODE     IN ('10', '20')
                                       AND D.ACTUAL_SALE_QTY != 0
                                     WHERE 1 = 1
                                       AND A.VER_CD = #{NEW_VER_CD, jdbcType=VARCHAR}
                                     GROUP BY A.VER_CD, A.STD_YYYYMMDD, B.BF_20D_YYYYMMDD, D.LIQUOR_CODE, C.DOW_CODE, C.DAY_OF_WEEK
                                     --ORDER BY A.VER_CD, A.STD_YYYYMMDD, B.BF_20D_YYYYMMDD, D.LIQUOR_CODE, C.DAY_OF_WEEK
                               )
                         WHERE 1 = 1
                   )
             WHERE 1 = 1
      ) S
   ON (T.VER_CD = S.VER_CD AND T.LIQUOR_CODE = S.LIQUOR_CODE AND T.SALE_SET_TYPE_CODE = S.SALE_SET_TYPE_CODE AND T.SEQNO = S.SEQNO)
 WHEN MATCHED THEN
    UPDATE
       SET T.VAL                = S.VAL
         , T.LAST_UPDATED_BY    = #{userId, jdbcType=VARCHAR}
         , T.LAST_UPDATE_DATE   = SYSDATE
 
 WHEN NOT MATCHED THEN
    INSERT (T.VER_CD, T.LIQUOR_CODE, T.SALE_SET_TYPE_CODE, T.SEQNO, T.VAL, T.DOW_CODE
            , T.USE_SALE_QTY_YYYYMM, T.SALE_VAR_APL_FR_DT, T.SALE_VAR_APL_TO_DT, T.SALE_VAR_NAME, T.SALE_VAR_TYPE, T.SALE_VAR_USAGE_CODE, T.SALE_VAR_ITEM_CODE, T.RMKS
            , T.ATTRIBUTE1, T.ATTRIBUTE2, T.ATTRIBUTE3, T.ATTRIBUTE4, T.ATTRIBUTE5, T.CREATED_BY, T.CREATION_DATE, T.LAST_UPDATED_BY, T.LAST_UPDATE_DATE)
    VALUES (S.VER_CD, S.LIQUOR_CODE, S.SALE_SET_TYPE_CODE, S.SEQNO, S.VAL, S.DOW_CODE
            , S.USE_SALE_QTY_YYYYMM, S.SALE_VAR_APL_FR_DT, S.SALE_VAR_APL_TO_DT, S.SALE_VAR_NAME, S.SALE_VAR_TYPE, S.SALE_VAR_USAGE_CODE, S.SALE_VAR_ITEM_CODE, S.RMKS
            , S.ATTRIBUTE1, S.ATTRIBUTE2, S.ATTRIBUTE3, S.ATTRIBUTE4, S.ATTRIBUTE5, #{userId, jdbcType=VARCHAR}, SYSDATE, #{userId, jdbcType=VARCHAR}, SYSDATE)
    </update>


    
    <!-- 버전 정보 조회 -->
    <select id="selectVerInfo" parameterType="map" resultType="map">
    SELECT /* com.hitejinro.snop.work.dao.M02020DaoMapper.selectVerInfo */
           A.VER_CD
         , A.VER_NM, A.VER_DESC
         , A.STD_YYYYMMDD, TO_CHAR(TO_DATE(A.STD_YYYYMMDD, 'YYYYMMDD'), 'YYYY-MM') AS STD_YYYYMM
         , A.USE_YN
         , A.VER_FR_DT, A.VER_TO_DT
         , TO_CHAR(A.WORK_DT_10, 'YYYY-MM-DD HH24:MI:SS') || ' ' || NVL(BA.USER_NM, A.WORK_USER_10) AS WORK_INFO_10
         , TO_CHAR(A.WORK_DT_20, 'YYYY-MM-DD HH24:MI:SS') || ' ' || NVL(BB.USER_NM, A.WORK_USER_20) AS WORK_INFO_20
         , TO_CHAR(A.WORK_DT_10, 'YYYY-MM-DD HH24:MI:SS') AS WORK_DT_10, A.WORK_USER_10, BA.USER_NM AS WORK_USER_10_NM
         , TO_CHAR(A.WORK_DT_20, 'YYYY-MM-DD HH24:MI:SS') AS WORK_DT_20, A.WORK_USER_20, BB.USER_NM AS WORK_USER_20_NM
         , A.PRDT_VAR_VER_CD, NVL(C.PRDT_VAR_VER_NM, 'N/A') AS PRDT_VAR_VER_NM, C.PRDT_VAR_VER_DESC
         
      FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_M A
 LEFT JOIN SCMU.W_SOP_TB_USER_M           BA
        ON BA.USER_ID = A.WORK_USER_10
 LEFT JOIN SCMU.W_SOP_TB_USER_M           BB
        ON BB.USER_ID = A.WORK_USER_20
 LEFT JOIN SCMU.W_SOP_TB_PRDT_VAR_M       C
        ON C.PRDT_VAR_VER_CD = A.PRDT_VAR_VER_CD
     WHERE 1 = 1
       AND A.VER_CD = #{verCd, jdbcType=VARCHAR}
    </select>

    <!-- 버전 정보의 작업정보 저장 -->
    <update id="updateVerWorkInfo" parameterType="map">
UPDATE /* com.hitejinro.snop.work.dao.M02020DaoMapper.updateVerWorkInfo */
       SCMU.W_SOP_TB_DALY_SCM_SIMUL_M T
   SET T.WORK_DT_10         = CASE WHEN #{liquorCode, jdbcType=VARCHAR} = '!ALL' THEN SYSDATE
                                   WHEN #{liquorCode, jdbcType=VARCHAR} = '10'   THEN SYSDATE
                                   ELSE                                               T.WORK_DT_10
                              END
     , T.WORK_USER_10       = CASE WHEN #{liquorCode, jdbcType=VARCHAR} = '!ALL' THEN #{userId, jdbcType=VARCHAR}
                                   WHEN #{liquorCode, jdbcType=VARCHAR} = '10'   THEN #{userId, jdbcType=VARCHAR}
                                   ELSE                                               T.WORK_USER_10
                              END
     , T.WORK_DT_20         = CASE WHEN #{liquorCode, jdbcType=VARCHAR} = '!ALL' THEN SYSDATE
                                   WHEN #{liquorCode, jdbcType=VARCHAR} = '20'   THEN SYSDATE
                                   ELSE                                               T.WORK_DT_20
                              END
     , T.WORK_USER_20       = CASE WHEN #{liquorCode, jdbcType=VARCHAR} = '!ALL' THEN #{userId, jdbcType=VARCHAR}
                                   WHEN #{liquorCode, jdbcType=VARCHAR} = '20'   THEN #{userId, jdbcType=VARCHAR}
                                   ELSE                                               T.WORK_USER_20
                              END
 WHERE 1 = 1
   AND T.VER_CD = #{verCd, jdbcType=VARCHAR}
    </update>



    <!-- 생산변수 리스트 조회 -->
    <select id="selectPrdtVarList" parameterType="map" resultType="map">
SELECT /* com.hitejinro.snop.work.dao.M02020DaoMapper.selectPrdtVarList */
       A.PRDT_VAR_VER_CD, A.PRDT_VAR_VER_NM
  FROM SCMU.W_SOP_TB_PRDT_VAR_M A
 WHERE 1 = 1
   AND A.USE_YN = 'Y'
 ORDER BY A.PRDT_VAR_VER_CD DESC
    </select>

    <!-- 생산변수 저장 -->
    <update id="updatePrdtVarVerCd" parameterType="map">
UPDATE /* com.hitejinro.snop.work.dao.M02020DaoMapper.updatePrdtVarVerCd */
       SCMU.W_SOP_TB_DALY_SCM_SIMUL_M T
   SET T.PRDT_VAR_VER_CD    = #{prdtVarVerCd, jdbcType=VARCHAR}
     , T.LAST_UPDATED_BY    = #{userId, jdbcType=VARCHAR}
     , T.LAST_UPDATE_DATE   = SYSDATE
 WHERE 1 = 1
   AND T.VER_CD = #{verCd, jdbcType=VARCHAR}
    </update>


    <!-- 주간근무일수유형별 근무형태 리스트(주당 생산기준 관리) 조회 -->
    <select id="selectSftPtrnDtyByWeekWorkDcntTpList" parameterType="map" resultType="map">
        <![CDATA[
SELECT /* com.hitejinro.snop.work.dao.M02020DaoMapper.selectSftPtrnDtyByWeekWorkDcntTpList */
       WEEK_WORK_DCNT_TP_CODE, WEEK_WORK_DCNT_TP_NAME
     , SFT_PTRN_DTY_CODE, SFT_PTRN_DTY_NAME
     , WORK_DCNT, WEEK_WORK_CNT
     , LIQUOR_CODE
  FROM (
            SELECT A.WEEK_WORK_DCNT_TP_CODE, B.NAME AS WEEK_WORK_DCNT_TP_NAME                       -- 주간근무일수유형
                 , A.SFT_PTRN_DTY_CODE, C.NAME AS SFT_PTRN_DTY_NAME                                 -- 근무형태
                 , A.WORK_DCNT                                                                      -- 주간일수유형별로 한 주당 근무형태의 작업일수. 즉, 근무형태가 한 주동안 반복되는 횟수
                 , SUM(A.WORK_DCNT) OVER (PARTITION BY A.WEEK_WORK_DCNT_TP_CODE, E.DAY_OF_WEEK) AS WEEK_WORK_CNT   -- 주간 근무일수(영업일수)
                 , NVL(DC.AVL_HR, 0) AS SFT_PTRN_DTY_AVL_HR
                 , A.LIQUOR_CODE, B.SEQ AS WEEK_WORK_DCNT_TP_SEQ, C.SEQ AS SFT_PTRN_DTY_SEQ
                 , ROW_NUMBER() OVER (PARTITION BY A.WEEK_WORK_DCNT_TP_CODE, A.SFT_PTRN_DTY_CODE ORDER BY E.DAY_OF_WEEK) AS RNUM
              FROM SCMU.W_SOP_TB_WEEK_PRDT_STD_M    A
         LEFT JOIN SCMU.W_SOP_TB_COM_CODE_M         B
                ON B.GROUP_CODE = 'WEEK_WORK_DCNT_TP' -- 주간근무일수유형
               AND B.CODE       = A.WEEK_WORK_DCNT_TP_CODE
         LEFT JOIN SCMU.W_SOP_TB_COM_CODE_M         C
                ON C.GROUP_CODE = 'SFT_PTRN_DTY' -- 근무형태
               AND C.CODE       = A.SFT_PTRN_DTY_CODE
         LEFT JOIN SCMU.W_SOP_TB_DALY_SCM_SIMUL_M   DA
                ON DA.VER_CD = #{verCd, jdbcType=VARCHAR}
         LEFT JOIN SCMU.W_SOP_TB_PRDT_VAR_M         DB
                ON DB.PRDT_VAR_VER_CD = DA.PRDT_VAR_VER_CD
         LEFT JOIN SCMU.W_SOP_TB_PRDT_VAR_SFT_HR_M  DC
                ON DC.PRDT_VAR_VER_CD   = DB.PRDT_VAR_VER_CD
               AND DC.SFT_PTRN_DTY_CODE = A.SFT_PTRN_DTY_CODE
        CROSS JOIN (    -- 근무형태별 반복되는 횟수를 하나씩 분리하기 위한 목적. 이렇게 해야, 화면단에서 처리가 편함
                        SELECT LEVEL AS DAY_OF_WEEK FROM DUAL CONNECT BY LEVEL <=7
                   )                                E
             WHERE 1 = 1
       )
 WHERE 1 = 1
   AND (
            --(WORK_DCNT = 0 AND RNUM = 1) OR       -- 근무형태를 사용하지 않더라도 표현
            (WORK_DCNT > 0 AND RNUM <= WORK_DCNT)   -- 근무형태가 사용되는 일수만큼만 표현
       )
     ORDER BY LIQUOR_CODE, WEEK_WORK_DCNT_TP_SEQ, WEEK_WORK_DCNT_TP_CODE, SFT_PTRN_DTY_AVL_HR DESC, SFT_PTRN_DTY_SEQ, SFT_PTRN_DTY_CODE
        ]]>
    </select>
    
    <!-- 생산변수의 근무형태 리스트 조회 -->
    <select id="selectSftPtrnDtyList" parameterType="map" resultType="map">
    SELECT /* com.hitejinro.snop.work.dao.M02020DaoMapper.selectSftPtrnDtyList */
           A.VER_CD, A.PRDT_VAR_VER_CD, C.LIQUOR_CODE
         , C.SFT_PTRN_DTY_CODE, D.NAME AS SFT_PTRN_DTY_NAME
         , C.AVL_HR
         --, A.STD_YYYYMMDD, A.VER_FR_DT, A.VER_TO_DT, NVL(B.PRDT_VAR_VER_NM, 'N/A') AS PRDT_VAR_VER_NM, B.PRDT_VAR_VER_DESC, B.USE_YN AS PRDT_VAR_VER_USE_YN

      FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_M  A
 LEFT JOIN SCMU.W_SOP_TB_PRDT_VAR_M        B
        ON B.PRDT_VAR_VER_CD = A.PRDT_VAR_VER_CD
 LEFT JOIN SCMU.W_SOP_TB_PRDT_VAR_SFT_HR_M C
        ON C.PRDT_VAR_VER_CD = B.PRDT_VAR_VER_CD
 LEFT JOIN SCMU.W_SOP_TB_COM_CODE_M        D
        ON D.GROUP_CODE = 'SFT_PTRN_DTY'
       AND D.CODE       = C.SFT_PTRN_DTY_CODE
     WHERE 1 = 1
       AND A.VER_CD = #{verCd, jdbcType=VARCHAR}
     ORDER BY C.LIQUOR_CODE, D.SEQ, C.SFT_PTRN_DTY_CODE
    </select>

    <!-- 생산설정의 그리드 헤더 조회 : 생산변수의 공장/라인 리스트 -->
    <select id="searchPrdtSetHeader" parameterType="map" resultType="map">
    SELECT /* com.hitejinro.snop.work.dao.M02020DaoMapper.searchPrdtSetHeader */
           A.VER_CD, A.STD_YYYYMMDD, A.VER_FR_DT, A.VER_TO_DT
         , A.PRDT_VAR_VER_CD, NVL(B.PRDT_VAR_VER_NM, 'N/A') AS PRDT_VAR_VER_NM, B.PRDT_VAR_VER_DESC, B.USE_YN AS PRDT_VAR_VER_USE_YN
         , C.LIQUOR_CODE
         , C.ORG_CODE, C.ORG_NAME
         , C.LINE_DEPT_CODE, C.LINE_DEPT_NAME, C.NEW_LINE_YN
         , 'COL_' || ROW_NUMBER() OVER (PARTITION BY C.LIQUOR_CODE ORDER BY C.ORG_CODE, DECODE(C.NEW_LINE_YN, 'Y', -1, 1), C.LINE_DEPT_CODE) AS COL_ID
         , CASE WHEN ROW_NUMBER() OVER (PARTITION BY C.LIQUOR_CODE, C.ORG_CODE ORDER BY DECODE(C.NEW_LINE_YN, 'Y', -1, 1), C.LINE_DEPT_CODE) = 1 THEN COUNT(1) OVER (PARTITION BY C.LIQUOR_CODE, C.ORG_CODE)
                ELSE 1
           END AS HEADER_COL_SPAN -- 공장별 라인의 개수(공장이 나오는 첫번째 라인에서만 View)
         
      FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_M A
      JOIN SCMU.W_SOP_TB_PRDT_VAR_M       B
        ON B.PRDT_VAR_VER_CD = A.PRDT_VAR_VER_CD
      JOIN (    -- C. 생산변수의 공장/라인/제품 리스트에서 공장/라인만 추출
                SELECT CA.PRDT_VAR_VER_CD
                     , CASE WHEN CA.ORG_CODE LIKE 'MH%' THEN '10'
                            WHEN CA.ORG_CODE LIKE 'MJ%' THEN '20'
                       END AS LIQUOR_CODE
                     , CA.ORG_CODE, MAX(CB.ORG_NAME) AS ORG_NAME
                     , CA.LINE_DEPT_CODE
                     , MAX(
                               CASE WHEN CA.NEW_LINE_YN = 'Y' THEN CD.LINE_DEPT_NAME
                                    ELSE                           CC.START_DEPARTMENT_DESC
                               END
                          ) AS LINE_DEPT_NAME
                     , MAX(NVL(CA.NEW_LINE_YN, 'N')) AS NEW_LINE_YN
                     
                  FROM SCMU.W_SOP_TB_PRDT_VAR_DTL_M      CA
             LEFT JOIN EDW.W_CM_TB_ORGANIZATION_M        CB
                    ON CB.ORG_CODE = CA.ORG_CODE
             LEFT JOIN EDW.W_PRD_TB_ITEM_ROUTING_F       CC
                    ON CC.ORG_CODE         = CA.ORG_CODE
                   AND CC.START_DEPARTMENT = CA.LINE_DEPT_CODE
             LEFT JOIN SCMU.W_SOP_TB_PRDT_VAR_NEW_LINE_M CD
                    ON CD.PRDT_VAR_VER_CD = CA.PRDT_VAR_VER_CD
                   AND CD.ORG_CODE        = CA.ORG_CODE
                   AND CD.LINE_DEPT_CODE  = CA.LINE_DEPT_CODE
                   AND 'Y'                = CA.NEW_LINE_YN -- 신규라인만 대상
                 WHERE 1 = 1
                   AND CA.NEW_LINE_YN != 'Y' -- 일자별 시뮬에서는 신규라인은 사용안함
                 GROUP BY CA.PRDT_VAR_VER_CD, CASE WHEN CA.ORG_CODE LIKE 'MH%' THEN '10' WHEN CA.ORG_CODE LIKE 'MJ%' THEN '20' END, CA.ORG_CODE, CA.LINE_DEPT_CODE
           )                              C
        ON C.PRDT_VAR_VER_CD = B.PRDT_VAR_VER_CD
       AND C.LIQUOR_CODE     = #{liquorCode, jdbcType=VARCHAR}
     WHERE 1 = 1
       AND A.VER_CD = #{verCd, jdbcType=VARCHAR}
     ORDER BY C.LIQUOR_CODE, C.ORG_CODE, DECODE(C.NEW_LINE_YN, 'Y', -1, 1), C.LINE_DEPT_CODE
    </select>
    
    <!-- 생산설정의 그리드 바디 조회 : 버전의 기간 리스트와 헤더의 조합 -->
    <select id="searchPrdtSetBody" parameterType="map" resultType="map">
    SELECT /* com.hitejinro.snop.work.dao.M02020DaoMapper.searchPrdtSetBody */
           A.VER_CD
         --, A.STD_YYYYMMDD, A.VER_FR_DT, A.VER_TO_DT, A.PRDT_VAR_VER_CD
         , C.LIQUOR_CODE, C.LIQUOR_DESC
         , D.PERIOD_TYPE, D.PERIOD_CODE, D.PERIOD_NAME
         , MAX(
                CASE WHEN D.PERIOD_TYPE = 'YYYYMM'   THEN ''
                     WHEN D.PERIOD_TYPE = 'YYYYWW'   THEN '    '
                     WHEN D.PERIOD_TYPE = 'YYYYMMDD' THEN '        '
                     ELSE                                 ''
                END
                || D.PERIOD_NAME
              ) AS PERIOD_DESC -- 기간유형에 따라서, 들여쓰기 처리
        <![CDATA[
         , MAX(
                CASE WHEN D.PERIOD_TYPE = 'YYYYMMDD' AND D.PERIOD_CODE <= A.STD_YYYYMMDD THEN D.PERIOD_TYPE || '_ACTUAL'
                     WHEN D.PERIOD_TYPE = 'YYYYMMDD' AND D.PERIOD_CODE >  A.STD_YYYYMMDD THEN D.PERIOD_TYPE || '_PLAN'
                     ELSE                                                                     D.PERIOD_TYPE
                END
              ) AS "Def"    -- 트리그리드의 행별 속성 설정 : YYYYMM, YYYYWW, YYYYMMDD
        ]]>
         , MAX(
                CASE WHEN D.PERIOD_TYPE = 'YYYYMMDD' AND NVL(D.BUSINESS_DAY_FLAG, 'N') = 'Y' THEN '정상'
                     WHEN D.PERIOD_TYPE = 'YYYYMMDD' AND NVL(D.BUSINESS_DAY_FLAG, 'N') = 'N' THEN '휴일'
                     ELSE                                                                         ''
                END
              ) AS BUSINESS_DAY_FLAG_DESC
         , D.BUSINESS_DAY_FLAG, D.PERIOD_FR_YYYYMMDD, D.PERIOD_TO_YYYYMMDD, D.PERIOD_TYPE_SEQ, MAX(D.CALENDAR_WORK_CNT) AS CALENDAR_WORK_CNT, MAX(D.WORK_CNT) AS WORK_CNT
         /* 공장/라인별로 근무형태(SFT_PTRN_DTY_CODE), 근무시간(AVL_HR)
         , MAX(CASE WHEN D.PERIOD_TYPE IN (          'YYYYWW', 'YYYYMMDD') AND E.ORG_CODE = 'MH1' AND E.LINE_DEPT_CODE = 'BTL1' THEN NVL(E.SFT_PTRN_DTY_CODE, '')   END) AS COL_1_SFT_PTRN_DTY_CODE
         , SUM(CASE WHEN D.PERIOD_TYPE IN (                    'YYYYMMDD') AND E.ORG_CODE = 'MH1' AND E.LINE_DEPT_CODE = 'BTL1' THEN NVL(E.AVL_HR, 0)
                    WHEN D.PERIOD_TYPE IN ('YYYYMM', 'YYYYWW'            ) AND F.ORG_CODE = 'MH1' AND F.LINE_DEPT_CODE = 'BTL1' THEN NVL(F.AVL_HR, 0)               END) AS COL_1_AVL_HR
         */
        <if test="TREEGRID_HEADER != '' and TREEGRID_HEADER != null">
            <foreach open="" collection="TREEGRID_HEADER" index="index" item="item" separator="" close="">
         , MAX(CASE WHEN D.PERIOD_TYPE IN (          'YYYYWW', 'YYYYMMDD') AND E.ORG_CODE = #{item.ORG_CODE, jdbcType=VARCHAR} AND E.LINE_DEPT_CODE = #{item.LINE_DEPT_CODE, jdbcType=VARCHAR} THEN NVL(E.SFT_PTRN_DTY_CODE, '')   END) AS ${item.COL_ID}_SFT_PTRN_DTY_CODE
         , SUM(CASE WHEN D.PERIOD_TYPE IN (                    'YYYYMMDD') AND E.ORG_CODE = #{item.ORG_CODE, jdbcType=VARCHAR} AND E.LINE_DEPT_CODE = #{item.LINE_DEPT_CODE, jdbcType=VARCHAR} THEN NVL(E.AVL_HR, 0)
                    WHEN D.PERIOD_TYPE IN ('YYYYMM', 'YYYYWW'            ) AND F.ORG_CODE = #{item.ORG_CODE, jdbcType=VARCHAR} AND F.LINE_DEPT_CODE = #{item.LINE_DEPT_CODE, jdbcType=VARCHAR} THEN NVL(F.AVL_HR, 0)               END) AS ${item.COL_ID}_AVL_HR
            </foreach>
        </if>
         
      FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_M       A
 LEFT JOIN SCMU.W_SOP_TB_PRDT_VAR_M             B
        ON B.PRDT_VAR_VER_CD = A.PRDT_VAR_VER_CD
      JOIN EDW.W_CM_TB_LIQUOR_M                 C
        ON C.LIQUOR_CODE = #{liquorCode, jdbcType=VARCHAR}
 LEFT JOIN (    -- D. 버전의 유효기간에 해당하는 날짜 리스트(월, 연주차, 일자)
                SELECT DB.VER_CD, DC.PERIOD_TYPE
                     , CASE WHEN DC.PERIOD_TYPE = 'YYYYMM'   THEN DA.YYYYMM
                            WHEN DC.PERIOD_TYPE = 'YYYYWW'   THEN DA.SCM_YYYYWW
                            WHEN DC.PERIOD_TYPE = 'YYYYMMDD' THEN DA.YYYYMMDD
                       END                  AS PERIOD_CODE
                     , CASE WHEN DC.PERIOD_TYPE = 'YYYYMM'   THEN MAX( SUBSTR(DA.YYYYMM, 1, 4) || '-' || SUBSTR(DA.YYYYMM, 5, 2) || '월' )
                            WHEN DC.PERIOD_TYPE = 'YYYYWW'   THEN MAX( SUBSTR(DA.SCM_YYYYWW, 1, 4) || '년 ' || SUBSTR(DA.SCM_YYYYWW, 5, 2) || '주차' ) || '(' || MIN(TO_CHAR(TO_DATE(DA.YYYYMMDD, 'YYYYMMDD'), 'MM/DD')) || '~' || MAX(TO_CHAR(TO_DATE(DA.YYYYMMDD, 'YYYYMMDD'), 'MM/DD')) || ')'
                            WHEN DC.PERIOD_TYPE = 'YYYYMMDD' THEN MAX( TO_CHAR(TO_DATE(DA.YYYYMMDD, 'YYYYMMDD'), 'YYYY-MM-DD') || ' (' || DA.DAY_OF_WEEK_DESC || ')' )
                       END                  AS PERIOD_NAME
                     , CASE WHEN DC.PERIOD_TYPE = 'YYYYMM'   THEN TO_CHAR(NULL)
                            WHEN DC.PERIOD_TYPE = 'YYYYWW'   THEN TO_CHAR(NULL)
                            WHEN DC.PERIOD_TYPE = 'YYYYMMDD' THEN MAX(DA.BUSINESS_DAY_FLAG)
                       END                  AS BUSINESS_DAY_FLAG
                     , MIN(DA.YYYYMMDD)     AS PERIOD_FR_YYYYMMDD
                     , MAX(DA.YYYYMMDD)     AS PERIOD_TO_YYYYMMDD
                     , MAX(DC.SEQ)          AS PERIOD_TYPE_SEQ
                     , CASE WHEN DC.PERIOD_TYPE = 'YYYYMM'   THEN MAX( DA.YYYYMM_WORK_CNT )
                            WHEN DC.PERIOD_TYPE = 'YYYYWW'   THEN MAX( DA.SCM_YYYYWW_WORK_CNT )
                            WHEN DC.PERIOD_TYPE = 'YYYYMMDD' THEN 1
                       END                  AS CALENDAR_WORK_CNT -- 기간의 영업일수 : 실제 달력상의 영업일수(월의 시작/종료 주차에서 일자가 잘려도 무시 )
                     , SUM(CASE WHEN DA.BUSINESS_DAY_FLAG = 'Y' THEN 1 ELSE 0 END) AS WORK_CNT -- 기간의 영업일수 : 월의 시작/종료 주차의 경우, 해당 월에 포함된 날짜만 계산
                     
                  FROM SCMU.W_SOP_VW_CALENDAR_M       DA
                  JOIN SCMU.W_SOP_TB_DALY_SCM_SIMUL_M DB
                    ON DA.YYYYMMDD BETWEEN DB.VER_FR_DT AND DB.VER_TO_DT
            CROSS JOIN (
                            SELECT 'YYYYMM' AS PERIOD_TYPE, 1 AS SEQ FROM DUAL UNION ALL
                            SELECT 'YYYYWW' AS PERIOD_TYPE, 2 AS SEQ FROM DUAL UNION ALL
                            SELECT 'YYYYMMDD' AS PERIOD_TYPE, 3 AS SEQ FROM DUAL
                       )                              DC
                 WHERE 1 = 1
                   AND DB.VER_CD = #{verCd, jdbcType=VARCHAR}
                 GROUP BY DB.VER_CD, DC.PERIOD_TYPE
                        , CASE WHEN DC.PERIOD_TYPE = 'YYYYMM'   THEN DA.YYYYMM
                               WHEN DC.PERIOD_TYPE = 'YYYYWW'   THEN DA.SCM_YYYYWW
                               WHEN DC.PERIOD_TYPE = 'YYYYMMDD' THEN DA.YYYYMMDD
                          END
           )                                    D
        ON D.VER_CD = A.VER_CD
 LEFT JOIN SCMU.W_SOP_TB_DALY_SCM_SIMUL_PRDT_F  E -- E. 생산설정 중 주차(YYYYWW)의 주간근무일수유형(WEEK_WORK_DCNT_TP_CODE)과 일자(YYYYMMDD)의 근무형태(SFT_PTRN_DTY_CODE), 근무시간(AVL_HR) 조회
        ON E.VER_CD      = A.VER_CD
       AND E.LIQUOR_CODE = C.LIQUOR_CODE
       AND E.PERIOD_TYPE = D.PERIOD_TYPE
       AND E.PERIOD_CODE = D.PERIOD_CODE
 LEFT JOIN SCMU.W_SOP_TB_DALY_SCM_SIMUL_PRDT_F  F -- F. 생산설정 중 월(YYYYMM), 주차(YYYYWW)의 근무시간(AVL_HR) 조회 : 하위 일자(YYYYMMDD)의 근무시간 합산
        ON F.VER_CD      = A.VER_CD
       AND F.LIQUOR_CODE = C.LIQUOR_CODE
       AND F.PERIOD_TYPE = 'YYYYMMDD'
       AND F.PERIOD_CODE BETWEEN D.PERIOD_FR_YYYYMMDD AND D.PERIOD_TO_YYYYMMDD
       AND D.PERIOD_TYPE IN ('YYYYMM', 'YYYYWW')
     WHERE 1 = 1
       AND A.VER_CD = #{verCd, jdbcType=VARCHAR}
     GROUP BY A.VER_CD, C.LIQUOR_CODE, C.LIQUOR_DESC, D.PERIOD_TYPE, D.PERIOD_CODE, D.PERIOD_NAME, D.BUSINESS_DAY_FLAG, D.PERIOD_FR_YYYYMMDD, D.PERIOD_TO_YYYYMMDD, D.PERIOD_TYPE_SEQ
     ORDER BY C.LIQUOR_CODE, D.PERIOD_FR_YYYYMMDD, D.PERIOD_TYPE_SEQ, D.PERIOD_CODE
    </select>
    
    <!-- 생산설정 데이터 저장 : 일자별 공장/라인의 근무형태/가용시간 삭제(근무형태가 N/A인경우) -->
    <update id="deletePrdtSet" parameterType="map">
DELETE /* com.hitejinro.snop.work.dao.M02020DaoMapper.deletePrdtSet */
  FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_PRDT_F T
 WHERE 1 = 1
   AND EXISTS (
            SELECT SA.VER_CD, SA.LIQUOR_CODE, SA.ORG_CODE, SA.LINE_DEPT_CODE, SA.PERIOD_TYPE, SA.PERIOD_CODE
                 , SA.SFT_PTRN_DTY_CODE         -- 주차(YYYYWW)에서는 주간근무일수유형(WEEK_WORK_DCNT_TP_CODE), 일자(YYYYMMDD)에서는 근무형태(SFT_PTRN_DTY_CODE)
              FROM (
        <foreach collection="updateList" item="list" separator="UNION ALL" index="i">
SELECT #{list.VER_CD, jdbcType=VARCHAR}                                                                     AS VER_CD
     , #{list.LIQUOR_CODE, jdbcType=VARCHAR}                                                                AS LIQUOR_CODE
     , #{list.ORG_CODE, jdbcType=VARCHAR}                                                                   AS ORG_CODE
     , #{list.LINE_DEPT_CODE, jdbcType=VARCHAR}                                                             AS LINE_DEPT_CODE
     , #{list.PERIOD_TYPE, jdbcType=VARCHAR}                                                                AS PERIOD_TYPE
     , #{list.PERIOD_CODE, jdbcType=VARCHAR}                                                                AS PERIOD_CODE
     , #{list.SFT_PTRN_DTY_CODE, jdbcType=VARCHAR}                                                          AS SFT_PTRN_DTY_CODE
     , #{list.PERIOD_FR_YYYYMMDD, jdbcType=VARCHAR}                                                         AS PERIOD_FR_YYYYMMDD
     , #{list.PERIOD_TO_YYYYMMDD, jdbcType=VARCHAR}                                                         AS PERIOD_TO_YYYYMMDD
     
     , #{list.action, jdbcType=VARCHAR}                                                                     AS ROW_ACTION   -- 행 상태 : insert, update, delete
     , ROWNUM                                                                                               AS RNUM
  FROM DUAL
        </foreach>
                   )                               SA
             WHERE 1 = 1
               AND (    -- 근무형태가 N/A이면, 삭제될 예정
                        (SA.SFT_PTRN_DTY_CODE IS NULL)
                        OR
                        (SA.SFT_PTRN_DTY_CODE = 'NA')
                        OR
                        (SA.SFT_PTRN_DTY_CODE = 'N/A')
                   )
               AND SA.VER_CD            = T.VER_CD
               AND SA.LIQUOR_CODE       = T.LIQUOR_CODE
               AND SA.ORG_CODE          = T.ORG_CODE
               AND SA.LINE_DEPT_CODE    = T.LINE_DEPT_CODE
               AND SA.PERIOD_TYPE       = T.PERIOD_TYPE
               AND SA.PERIOD_CODE       = T.PERIOD_CODE
       )
    </update>
    
    <!-- 생산설정 데이터 저장 : 일자별 공장/라인의 근무형태/가용시간 저장 -->
    <update id="updatePrdtSet" parameterType="map">
MERGE /* com.hitejinro.snop.work.dao.M02020DaoMapper.updatePrdtSet */
 INTO SCMU.W_SOP_TB_DALY_SCM_SIMUL_PRDT_F T
USING (
            SELECT SA.VER_CD, SA.LIQUOR_CODE, SA.ORG_CODE, SA.LINE_DEPT_CODE, SA.PERIOD_TYPE, SA.PERIOD_CODE
                 , SA.SFT_PTRN_DTY_CODE         -- 주차(YYYYWW)에서는 주간근무일수유형(WEEK_WORK_DCNT_TP_CODE), 일자(YYYYMMDD)에서는 근무형태(SFT_PTRN_DTY_CODE)
                 , NVL(SD.AVL_HR, 0) AS AVL_HR  -- 생산변수의 근무형태에 저장된 가용시간 : 실제 저장에 사용할 부분
                 , SA.PERIOD_FR_YYYYMMDD, SA.PERIOD_TO_YYYYMMDD
                 , CASE WHEN SA.PERIOD_TYPE = 'YYYYWW'  THEN SG.WEEK_WORK_DCNT_TP_NAME
                        WHEN SA.PERIOD_TYPE = 'YYYYMMDD'THEN SE.NAME
                   END AS SFT_PTRN_DTY_NAME
                 , SF.LINE_DEPT_NAME, SF.NEW_LINE_YN
                 , CASE WHEN SA.PERIOD_TYPE = 'YYYYWW'  THEN '주간근무일수유형(WEEK_WORK_DCNT_TP_CODE)=' || SG.WEEK_WORK_DCNT_TP_DESC
                        WHEN SA.PERIOD_TYPE = 'YYYYMMDD'THEN '근무형태(SFT_PTRN_DTY_CODE)=' || '[' || SA.SFT_PTRN_DTY_CODE || ']' || SE.NAME || ' : ' || '근무시간(AVL_HR)=' || SD.AVL_HR
                   END AS RMKS
                 , NULL AS ATTRIBUTE1, NULL AS ATTRIBUTE2, NULL AS ATTRIBUTE3, NULL AS ATTRIBUTE4, NULL AS ATTRIBUTE5
                 
              FROM (
        <foreach collection="updateList" item="list" separator="UNION ALL" index="i">
SELECT #{list.VER_CD, jdbcType=VARCHAR}                                                                     AS VER_CD
     , #{list.LIQUOR_CODE, jdbcType=VARCHAR}                                                                AS LIQUOR_CODE
     , #{list.ORG_CODE, jdbcType=VARCHAR}                                                                   AS ORG_CODE
     , #{list.LINE_DEPT_CODE, jdbcType=VARCHAR}                                                             AS LINE_DEPT_CODE
     , #{list.PERIOD_TYPE, jdbcType=VARCHAR}                                                                AS PERIOD_TYPE
     , #{list.PERIOD_CODE, jdbcType=VARCHAR}                                                                AS PERIOD_CODE
     , #{list.SFT_PTRN_DTY_CODE, jdbcType=VARCHAR}                                                          AS SFT_PTRN_DTY_CODE
     , #{list.PERIOD_FR_YYYYMMDD, jdbcType=VARCHAR}                                                         AS PERIOD_FR_YYYYMMDD
     , #{list.PERIOD_TO_YYYYMMDD, jdbcType=VARCHAR}                                                         AS PERIOD_TO_YYYYMMDD
     
     , #{list.action, jdbcType=VARCHAR}                                                                     AS ROW_ACTION   -- 행 상태 : insert, update, delete
     , ROWNUM                                                                                               AS RNUM
  FROM DUAL
        </foreach>
                   )                               SA
         LEFT JOIN SCMU.W_SOP_TB_DALY_SCM_SIMUL_M  SB
                ON SB.VER_CD = SA.VER_CD
         LEFT JOIN SCMU.W_SOP_TB_PRDT_VAR_M        SC
                ON SC.PRDT_VAR_VER_CD = SB.PRDT_VAR_VER_CD
         LEFT JOIN SCMU.W_SOP_TB_PRDT_VAR_SFT_HR_M SD
                ON SD.PRDT_VAR_VER_CD   = SC.PRDT_VAR_VER_CD
               AND SD.SFT_PTRN_DTY_CODE = SA.SFT_PTRN_DTY_CODE
         LEFT JOIN SCMU.W_SOP_TB_COM_CODE_M        SE
                ON SE.GROUP_CODE = 'SFT_PTRN_DTY'
               AND SE.CODE       = SD.SFT_PTRN_DTY_CODE
         LEFT JOIN (    -- SF. 생산변수의 공장/라인/제품 리스트에서 공장/라인만 추출
                        SELECT CA.PRDT_VAR_VER_CD
                             , CASE WHEN CA.ORG_CODE LIKE 'MH%' THEN '10'
                                    WHEN CA.ORG_CODE LIKE 'MJ%' THEN '20'
                               END AS LIQUOR_CODE
                             , CA.ORG_CODE, MAX(CB.ORG_NAME) AS ORG_NAME
                             , CA.LINE_DEPT_CODE
                             , MAX(
                                       CASE WHEN CA.NEW_LINE_YN = 'Y' THEN CD.LINE_DEPT_NAME
                                            ELSE                           CC.START_DEPARTMENT_DESC
                                       END
                                  ) AS LINE_DEPT_NAME
                             , MAX(NVL(CA.NEW_LINE_YN, 'N')) AS NEW_LINE_YN
                             
                          FROM SCMU.W_SOP_TB_PRDT_VAR_DTL_M      CA
                     LEFT JOIN EDW.W_CM_TB_ORGANIZATION_M        CB
                            ON CB.ORG_CODE = CA.ORG_CODE
                     LEFT JOIN EDW.W_PRD_TB_ITEM_ROUTING_F       CC
                            ON CC.ORG_CODE         = CA.ORG_CODE
                           AND CC.START_DEPARTMENT = CA.LINE_DEPT_CODE
                     LEFT JOIN SCMU.W_SOP_TB_PRDT_VAR_NEW_LINE_M CD
                            ON CD.PRDT_VAR_VER_CD = CA.PRDT_VAR_VER_CD
                           AND CD.ORG_CODE        = CA.ORG_CODE
                           AND CD.LINE_DEPT_CODE  = CA.LINE_DEPT_CODE
                           AND 'Y'                = CA.NEW_LINE_YN -- 신규라인만 대상
                         WHERE 1 = 1
                           AND CA.NEW_LINE_YN != 'Y' -- 일자별 시뮬에서는 신규라인은 사용안함
                         GROUP BY CA.PRDT_VAR_VER_CD, CASE WHEN CA.ORG_CODE LIKE 'MH%' THEN '10' WHEN CA.ORG_CODE LIKE 'MJ%' THEN '20' END, CA.ORG_CODE, CA.LINE_DEPT_CODE
                   )                              SF
                ON SF.PRDT_VAR_VER_CD = SB.PRDT_VAR_VER_CD
               AND SF.LIQUOR_CODE     = SA.LIQUOR_CODE
               AND SF.ORG_CODE        = SA.ORG_CODE
               AND SF.LINE_DEPT_CODE  = SA.LINE_DEPT_CODE
         LEFT JOIN (    -- SG. 주간근무일수유형(WEEK_WORK_DCNT_TP_CODE) 리스트 : 기간구분이 주차(YYYYWW)일때 정보 저장용
                        SELECT WEEK_WORK_DCNT_TP_CODE, WEEK_WORK_DCNT_TP_NAME
                             , '[' || WEEK_WORK_DCNT_TP_CODE || ']' || WEEK_WORK_DCNT_TP_NAME
                               || ' : '|| LISTAGG('[' || SFT_PTRN_DTY_CODE || ']' || SFT_PTRN_DTY_NAME || '(주간근무일수=' || WORK_DCNT || ')', ', ') WITHIN GROUP (ORDER BY SFT_PTRN_DTY_SEQ, SFT_PTRN_DTY_CODE) AS WEEK_WORK_DCNT_TP_DESC
                          FROM (
                                    SELECT A.WEEK_WORK_DCNT_TP_CODE, B.NAME AS WEEK_WORK_DCNT_TP_NAME                       -- 주간근무일수유형
                                         , A.SFT_PTRN_DTY_CODE, C.NAME AS SFT_PTRN_DTY_NAME                                 -- 근무형태
                                         , A.WORK_DCNT                                                                      -- 주간일수유형별로 한 주당 근무형태의 작업일수. 즉, 근무형태가 한 주동안 반복되는 횟수
                                         , SUM(A.WORK_DCNT) OVER (PARTITION BY A.WEEK_WORK_DCNT_TP_CODE) AS WEEK_WORK_CNT   -- 주간 근무일수(영업일수)
                                         , A.LIQUOR_CODE, B.SEQ AS WEEK_WORK_DCNT_TP_SEQ, C.SEQ AS SFT_PTRN_DTY_SEQ
                                      FROM SCMU.W_SOP_TB_WEEK_PRDT_STD_M    A
                                 LEFT JOIN SCMU.W_SOP_TB_COM_CODE_M         B
                                        ON B.GROUP_CODE = 'WEEK_WORK_DCNT_TP' -- 주간근무일수유형
                                       AND B.CODE       = A.WEEK_WORK_DCNT_TP_CODE
                                 LEFT JOIN SCMU.W_SOP_TB_COM_CODE_M         C
                                        ON C.GROUP_CODE = 'SFT_PTRN_DTY' -- 근무형태
                                       AND C.CODE       = A.SFT_PTRN_DTY_CODE
                                     WHERE 1 = 1
                               )
                         WHERE 1 = 1
                         GROUP BY WEEK_WORK_DCNT_TP_CODE, WEEK_WORK_DCNT_TP_NAME
                   )                              SG
                ON SG.WEEK_WORK_DCNT_TP_CODE = SA.SFT_PTRN_DTY_CODE
             WHERE 1 = 1
               AND (    -- 근무형태가 N/A이면, 삭제될 예정
                        (SA.SFT_PTRN_DTY_CODE IS NOT NULL)
                        AND
                        (SA.SFT_PTRN_DTY_CODE != 'NA')
                        AND
                        (SA.SFT_PTRN_DTY_CODE != 'N/A')
                   )
               AND SA.SFT_PTRN_DTY_CODE IS NOT NULL -- 근무형태가 N/A이면, 삭제될 예정
      ) S
   ON (T.VER_CD = S.VER_CD AND T.LIQUOR_CODE = S.LIQUOR_CODE AND T.ORG_CODE = S.ORG_CODE AND T.LINE_DEPT_CODE = S.LINE_DEPT_CODE AND T.PERIOD_TYPE = S.PERIOD_TYPE AND T.PERIOD_CODE = S.PERIOD_CODE)
 WHEN MATCHED THEN
    UPDATE
       SET T.SFT_PTRN_DTY_CODE  = S.SFT_PTRN_DTY_CODE
         , T.AVL_HR             = S.AVL_HR
         , T.PERIOD_FR_YYYYMMDD = S.PERIOD_FR_YYYYMMDD
         , T.PERIOD_TO_YYYYMMDD = S.PERIOD_TO_YYYYMMDD
         , T.SFT_PTRN_DTY_NAME  = S.SFT_PTRN_DTY_NAME
         , T.LINE_DEPT_NAME     = S.LINE_DEPT_NAME
         , T.NEW_LINE_YN        = S.NEW_LINE_YN
         , T.RMKS               = S.RMKS
         , T.LAST_UPDATED_BY    = #{userId, jdbcType=VARCHAR}
         , T.LAST_UPDATE_DATE   = SYSDATE
 
 WHEN NOT MATCHED THEN
    INSERT (T.VER_CD, T.LIQUOR_CODE, T.ORG_CODE, T.LINE_DEPT_CODE, T.PERIOD_TYPE, T.PERIOD_CODE
            , T.SFT_PTRN_DTY_CODE, T.AVL_HR, T.PERIOD_FR_YYYYMMDD, T.PERIOD_TO_YYYYMMDD, T.SFT_PTRN_DTY_NAME, T.LINE_DEPT_NAME, T.NEW_LINE_YN, T.RMKS
            , T.ATTRIBUTE1, T.ATTRIBUTE2, T.ATTRIBUTE3, T.ATTRIBUTE4, T.ATTRIBUTE5, T.CREATED_BY, T.CREATION_DATE, T.LAST_UPDATED_BY, T.LAST_UPDATE_DATE)
    VALUES (S.VER_CD, S.LIQUOR_CODE, S.ORG_CODE, S.LINE_DEPT_CODE, S.PERIOD_TYPE, S.PERIOD_CODE
            , S.SFT_PTRN_DTY_CODE, S.AVL_HR, S.PERIOD_FR_YYYYMMDD, S.PERIOD_TO_YYYYMMDD, S.SFT_PTRN_DTY_NAME, S.LINE_DEPT_NAME, S.NEW_LINE_YN, S.RMKS
            , S.ATTRIBUTE1, S.ATTRIBUTE2, S.ATTRIBUTE3, S.ATTRIBUTE4, S.ATTRIBUTE5, #{userId, jdbcType=VARCHAR}, SYSDATE, #{userId, jdbcType=VARCHAR}, SYSDATE)
    </update>

    
    <!-- 생산설정 갱신 초기화 : 허용되지 않는 근무형태와 공장/라인 리스트 삭제 -->
    <update id="deletePrdtSetRefresh" parameterType="map">
DELETE /* com.hitejinro.snop.work.dao.M02020DaoMapper.deletePrdtSetRefresh */
  FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_PRDT_F T
 WHERE 1 = 1
   AND T.VER_CD = #{verCd, jdbcType=VARCHAR}
   AND NOT EXISTS (
        -- Z. 현재 허용되는 근무형태 리스트 + 공장/라인 리스트
        SELECT B.VER_CD, A.PERIOD_TYPE, A.LIQUOR_CODE
             , A.SFT_PTRN_DTY_CODE, A.SFT_PTRN_DTY_NAME, A.AVL_HR
             , B.ORG_CODE, B.ORG_NAME, B.LINE_DEPT_CODE, B.LINE_DEPT_NAME, B.NEW_LINE_YN
          FROM (
                    -- A. 기간구분별 근무형태 리스트
                    SELECT 'YYYYWW' AS PERIOD_TYPE, AA.SEGMENT2 AS LIQUOR_CODE
                         , AA.CODE AS SFT_PTRN_DTY_CODE, AA.NAME AS SFT_PTRN_DTY_NAME -- 실제로는 주간근무일수유형이지만, 동일 컬럼에 주간근무일수유형과 근무형태를 혼용해서 사용(컬럼명이 근무형태임)
                         , 0 AS AVL_HR
                      FROM SCMU.W_SOP_TB_COM_CODE_M AA
                     WHERE 1 = 1
                       AND AA.GROUP_CODE = 'WEEK_WORK_DCNT_TP' -- 주간근무일수유형
                       AND AA.USE_YN     = 'Y'
                     UNION ALL
                    SELECT 'YYYYMMDD' AS PERIOD_TYPPE, AC.LIQUOR_CODE
                         , AC.SFT_PTRN_DTY_CODE, AD.NAME AS SFT_PTRN_DTY_NAME
                         , AC.AVL_HR
                      FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_M   AA
                      JOIN SCMU.W_SOP_TB_PRDT_VAR_M         AB
                        ON AB.PRDT_VAR_VER_CD = AA.PRDT_VAR_VER_CD
                      JOIN SCMU.W_SOP_TB_PRDT_VAR_SFT_HR_M  AC
                        ON AC.PRDT_VAR_VER_CD = AB.PRDT_VAR_VER_CD
                 LEFT JOIN SCMU.W_SOP_TB_COM_CODE_M         AD
                        ON AD.GROUP_CODE = 'SFT_PTRN_DTY' -- 근무형태
                       AND AD.CODE       = AC.SFT_PTRN_DTY_CODE
                     WHERE 1 = 1
                       AND AA.VER_CD = #{verCd, jdbcType=VARCHAR}
               ) A
          JOIN (
                    -- B. 생산변수의 공장/라인/제품 리스트에서 공장/라인만 추출
                    SELECT BA.VER_CD, BA.PRDT_VAR_VER_CD
                         , CASE WHEN BB.ORG_CODE LIKE 'MH%' THEN '10'
                                WHEN BB.ORG_CODE LIKE 'MJ%' THEN '20'
                           END AS LIQUOR_CODE
                         , BB.ORG_CODE, NVL(MAX(BC.ORG_NAME), BB.ORG_CODE) AS ORG_NAME
                         , BB.LINE_DEPT_CODE
                         , MAX(
                                   CASE WHEN BB.NEW_LINE_YN = 'Y' THEN NVL(BE.LINE_DEPT_NAME, BB.LINE_DEPT_CODE)
                                        ELSE                           NVL(BD.START_DEPARTMENT_DESC, BB.LINE_DEPT_CODE)
                                   END
                              ) AS LINE_DEPT_NAME
                         , MAX(NVL(BB.NEW_LINE_YN, 'N')) AS NEW_LINE_YN
                                     
                      FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_M    BA
                      JOIN SCMU.W_SOP_TB_PRDT_VAR_DTL_M      BB
                        ON BB.PRDT_VAR_VER_CD = BA.PRDT_VAR_VER_CD
                 LEFT JOIN EDW.W_CM_TB_ORGANIZATION_M        BC
                        ON BC.ORG_CODE = BB.ORG_CODE
                 LEFT JOIN EDW.W_PRD_TB_ITEM_ROUTING_F       BD
                        ON BD.ORG_CODE         = BB.ORG_CODE
                       AND BD.START_DEPARTMENT = BB.LINE_DEPT_CODE
                 LEFT JOIN SCMU.W_SOP_TB_PRDT_VAR_NEW_LINE_M BE
                        ON BE.PRDT_VAR_VER_CD = BA.PRDT_VAR_VER_CD
                       AND BE.ORG_CODE        = BB.ORG_CODE
                       AND BE.LINE_DEPT_CODE  = BB.LINE_DEPT_CODE
                       AND 'Y'                = BB.NEW_LINE_YN -- 신규라인만 대상
                     WHERE 1 = 1
                       AND BA.VER_CD      = #{verCd, jdbcType=VARCHAR}
                       AND BB.NEW_LINE_YN != 'Y' -- 일자별 시뮬에서는 신규라인은 사용안함
                     GROUP BY BA.VER_CD, BA.PRDT_VAR_VER_CD, CASE WHEN BB.ORG_CODE LIKE 'MH%' THEN '10' WHEN BB.ORG_CODE LIKE 'MJ%' THEN '20' END, BB.ORG_CODE, BB.LINE_DEPT_CODE
               ) B
            ON B.LIQUOR_CODE = A.LIQUOR_CODE
         WHERE 1 = 1
           AND T.VER_CD            = B.VER_CD 
           AND T.LIQUOR_CODE       = A.LIQUOR_CODE 
           AND T.ORG_CODE          = B.ORG_CODE
           AND T.LINE_DEPT_CODE    = B.LINE_DEPT_CODE
           AND T.PERIOD_TYPE       = A.PERIOD_TYPE
           AND T.SFT_PTRN_DTY_CODE = A.SFT_PTRN_DTY_CODE
       )
    </update>

    <!-- 생산설정 갱신 Update : 근무형태에 따른 가용시간과 공장/라인의 명칭 Update -->
    <update id="updatePrdtSetRefresh" parameterType="map">
MERGE /* com.hitejinro.snop.work.dao.M02020DaoMapper.deletePrdtSetRefresh */
 INTO SCMU.W_SOP_TB_DALY_SCM_SIMUL_PRDT_F T
USING (
            SELECT SA.VER_CD, SA.LIQUOR_CODE, SA.ORG_CODE, SA.LINE_DEPT_CODE, SA.PERIOD_TYPE, SB.PERIOD_CODE
                 , SA.SFT_PTRN_DTY_CODE, SA.SFT_PTRN_DTY_NAME, SA.AVL_HR
                 , SA.ORG_NAME, SA.LINE_DEPT_NAME, SA.NEW_LINE_YN
              FROM (    -- SA. 현재 허용되는 근무형태 리스트 + 공장/라인 리스트
                        SELECT B.VER_CD, A.PERIOD_TYPE, A.LIQUOR_CODE
                             , A.SFT_PTRN_DTY_CODE, A.SFT_PTRN_DTY_NAME, A.AVL_HR
                             , B.ORG_CODE, B.ORG_NAME, B.LINE_DEPT_CODE, B.LINE_DEPT_NAME, B.NEW_LINE_YN
                          FROM (
                                    -- A. 기간구분별 근무형태 리스트
                                    SELECT 'YYYYWW' AS PERIOD_TYPE, AA.SEGMENT2 AS LIQUOR_CODE
                                         , AA.CODE AS SFT_PTRN_DTY_CODE, AA.NAME AS SFT_PTRN_DTY_NAME -- 실제로는 주간근무일수유형이지만, 동일 컬럼에 주간근무일수유형과 근무형태를 혼용해서 사용(컬럼명이 근무형태임)
                                         , 0 AS AVL_HR
                                      FROM SCMU.W_SOP_TB_COM_CODE_M AA
                                     WHERE 1 = 1
                                       AND AA.GROUP_CODE = 'WEEK_WORK_DCNT_TP' -- 주간근무일수유형
                                       AND AA.USE_YN     = 'Y'
                                     UNION ALL
                                    SELECT 'YYYYMMDD' AS PERIOD_TYPPE, AC.LIQUOR_CODE
                                         , AC.SFT_PTRN_DTY_CODE, AD.NAME AS SFT_PTRN_DTY_NAME
                                         , AC.AVL_HR
                                      FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_M   AA
                                      JOIN SCMU.W_SOP_TB_PRDT_VAR_M         AB
                                        ON AB.PRDT_VAR_VER_CD = AA.PRDT_VAR_VER_CD
                                      JOIN SCMU.W_SOP_TB_PRDT_VAR_SFT_HR_M  AC
                                        ON AC.PRDT_VAR_VER_CD = AB.PRDT_VAR_VER_CD
                                 LEFT JOIN SCMU.W_SOP_TB_COM_CODE_M         AD
                                        ON AD.GROUP_CODE = 'SFT_PTRN_DTY' -- 근무형태
                                       AND AD.CODE       = AC.SFT_PTRN_DTY_CODE
                                     WHERE 1 = 1
                                       AND AA.VER_CD = #{verCd, jdbcType=VARCHAR}
                               ) A
                          JOIN (
                                    -- B. 생산변수의 공장/라인/제품 리스트에서 공장/라인만 추출
                                    SELECT BA.VER_CD, BA.PRDT_VAR_VER_CD
                                         , CASE WHEN BB.ORG_CODE LIKE 'MH%' THEN '10'
                                                WHEN BB.ORG_CODE LIKE 'MJ%' THEN '20'
                                           END AS LIQUOR_CODE
                                         , BB.ORG_CODE, NVL(MAX(BC.ORG_NAME), BB.ORG_CODE) AS ORG_NAME
                                         , BB.LINE_DEPT_CODE
                                         , MAX(
                                                   CASE WHEN BB.NEW_LINE_YN = 'Y' THEN NVL(BE.LINE_DEPT_NAME, BB.LINE_DEPT_CODE)
                                                        ELSE                           NVL(BD.START_DEPARTMENT_DESC, BB.LINE_DEPT_CODE)
                                                   END
                                              ) AS LINE_DEPT_NAME
                                         , MAX(NVL(BB.NEW_LINE_YN, 'N')) AS NEW_LINE_YN
                                                     
                                      FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_M    BA
                                      JOIN SCMU.W_SOP_TB_PRDT_VAR_DTL_M      BB
                                        ON BB.PRDT_VAR_VER_CD = BA.PRDT_VAR_VER_CD
                                 LEFT JOIN EDW.W_CM_TB_ORGANIZATION_M        BC
                                        ON BC.ORG_CODE = BB.ORG_CODE
                                 LEFT JOIN EDW.W_PRD_TB_ITEM_ROUTING_F       BD
                                        ON BD.ORG_CODE         = BB.ORG_CODE
                                       AND BD.START_DEPARTMENT = BB.LINE_DEPT_CODE
                                 LEFT JOIN SCMU.W_SOP_TB_PRDT_VAR_NEW_LINE_M BE
                                        ON BE.PRDT_VAR_VER_CD = BA.PRDT_VAR_VER_CD
                                       AND BE.ORG_CODE        = BB.ORG_CODE
                                       AND BE.LINE_DEPT_CODE  = BB.LINE_DEPT_CODE
                                       AND 'Y'                = BB.NEW_LINE_YN -- 신규라인만 대상
                                     WHERE 1 = 1
                                       AND BA.VER_CD      = #{verCd, jdbcType=VARCHAR}
                                       AND BB.NEW_LINE_YN != 'Y' -- 일자별 시뮬에서는 신규라인은 사용안함
                                     GROUP BY BA.VER_CD, BA.PRDT_VAR_VER_CD, CASE WHEN BB.ORG_CODE LIKE 'MH%' THEN '10' WHEN BB.ORG_CODE LIKE 'MJ%' THEN '20' END, BB.ORG_CODE, BB.LINE_DEPT_CODE
                               ) B
                            ON B.LIQUOR_CODE = A.LIQUOR_CODE
                         WHERE 1 = 1
                   )                                   SA
              JOIN SCMU.W_SOP_TB_DALY_SCM_SIMUL_PRDT_F SB
                ON SA.VER_CD            = SB.VER_CD
               AND SA.LIQUOR_CODE       = SB.LIQUOR_CODE
               AND SA.ORG_CODE          = SB.ORG_CODE
               AND SA.LINE_DEPT_CODE    = SB.LINE_DEPT_CODE
               AND SA.PERIOD_TYPE       = SB.PERIOD_TYPE
               AND SA.SFT_PTRN_DTY_CODE = SB.SFT_PTRN_DTY_CODE
             WHERE 1 = 1
      ) S
   ON (T.VER_CD = S.VER_CD AND T.LIQUOR_CODE = S.LIQUOR_CODE AND T.ORG_CODE = S.ORG_CODE AND T.LINE_DEPT_CODE = S.LINE_DEPT_CODE AND T.PERIOD_TYPE = S.PERIOD_TYPE AND T.PERIOD_CODE = S.PERIOD_CODE)
 WHEN MATCHED THEN
    UPDATE
       SET T.AVL_HR             = S.AVL_HR
         , T.SFT_PTRN_DTY_NAME  = S.SFT_PTRN_DTY_NAME
         , T.LINE_DEPT_NAME     = S.LINE_DEPT_NAME
         , T.LAST_UPDATED_BY    = CASE WHEN NVL(T.AVL_HR, 0) = NVL(S.AVL_HR, 0) AND T.SFT_PTRN_DTY_NAME = S.SFT_PTRN_DTY_NAME AND T.LINE_DEPT_NAME = S.LINE_DEPT_NAME THEN T.LAST_UPDATED_BY
                                       ELSE #{userId, jdbcType=VARCHAR}
                                  END
         , T.LAST_UPDATE_DATE   = CASE WHEN NVL(T.AVL_HR, 0) = NVL(S.AVL_HR, 0) AND T.SFT_PTRN_DTY_NAME = S.SFT_PTRN_DTY_NAME AND T.LINE_DEPT_NAME = S.LINE_DEPT_NAME THEN T.LAST_UPDATE_DATE
                                       ELSE SYSDATE
                                  END
    </update>



    <!-- 판매설정의 그리드 헤더 조회 : 선택된 월별 사용판매량으로 계산된 제품 리스트(모제품매핑 처리가 이미 되어있음) -->
    <select id="searchSaleSetHeader" parameterType="map" resultType="map">
    SELECT /* com.hitejinro.snop.work.dao.M02020DaoMapper.searchSaleSetHeader */
           A.VER_CD, B.LIQUOR_CODE, B.ITEM_CODE
         , MAX(C.DESCRIPTION) AS ITEM_NAME
         , MAX(C.ITEM_TYPE) AS ITEM_TYPE, MAX(C.ITEM_STATUS) AS ITEM_STATUS
         , MAX(C.BRAND_CODE) AS BRAND_CODE, MAX(C.BRAND_NAME) AS BRAND_NAME, MAX(C.BRAND_SORT_ORDER) AS BRAND_SORT_ORDER
         , MAX(C.VESSEL_CODE) AS VESSEL_CODE, MAX(C.VESSEL_SORT) AS VESSEL_SORT, MAX(C.VESSEL_SORT_ORDER) AS VESSEL_SORT_ORDER
         , MAX(C.USAGE_CODE) AS USAGE_CODE, MAX(C.USAGE_NAME) AS USAGE_NAME, MAX(C.USAGE_SORT_ORDER) AS USAGE_SORT_ORDER
         , MAX(C.VOLUME_VALUE) AS VOLUME_VALUE
         , MAX(C.UOM_CONVERSION_VALUE) AS UOM_CONVERSION_VALUE
         , 'COL_' || ROW_NUMBER() OVER (PARTITION BY A.VER_CD, B.LIQUOR_CODE ORDER BY SUM(B.SALE_QTY) * MAX(C.UOM_CONVERSION_VALUE) DESC, MAX(C.BRAND_SORT_ORDER), MAX(C.BRAND_NAME), MAX(C.DESCRIPTION), B.ITEM_CODE) AS COL_ID

      FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_M      A
      JOIN SCMU.W_SOP_TB_DALY_SCM_SIMUL_SALE_F B
        ON B.VER_CD      = A.VER_CD
       AND B.ITEM_MAP_YN = 'Y' -- 제품매핑여부=Y : N은 검증용이니, 실제 사용하는 Y(모제품 매핑 후)를 사용
      JOIN EDW.W_CM_TB_FG_ITEM_M               C
        ON C.ITEM_CODE = B.ITEM_CODE
     WHERE 1 = 1
       AND A.VER_CD      = #{verCd, jdbcType=VARCHAR}
       AND B.LIQUOR_CODE = #{liquorCode, jdbcType=VARCHAR}
       AND (    -- 내수/수출
                (#{domExpCode, jdbcType=VARCHAR} = '!ALL' AND 1 = 1)
                OR
                (#{domExpCode, jdbcType=VARCHAR} = C.DOM_EXP_CODE)
           )
       AND (    -- 용기
                (#{vesselCode, jdbcType=VARCHAR} = '!ALL' AND 1 = 1)
                OR
                (#{vesselCode, jdbcType=VARCHAR} = C.VESSEL_CODE)
           )
       AND (    -- 용도 : 다중 선택 가능
                (NVL(#{usageCode, jdbcType=VARCHAR}, '!ALL') = '!ALL' AND 1 = 1)
                OR
                (C.USAGE_CODE IN (SELECT REGEXP_SUBSTR(#{usageCode, jdbcType=VARCHAR}, '[^,]+', 1, LEVEL) AS ORG_CODE FROM DUAL CONNECT BY REGEXP_SUBSTR(#{usageCode, jdbcType=VARCHAR}, '[^,]+', 1, LEVEL) IS NOT NULL))
           )
     GROUP BY A.VER_CD, B.LIQUOR_CODE, B.ITEM_CODE
     ORDER BY SUM(B.SALE_QTY) * MAX(C.UOM_CONVERSION_VALUE) DESC -- 판매량이 높은 것부터
            , MAX(C.BRAND_SORT_ORDER), MAX(C.BRAND_NAME), MAX(C.DESCRIPTION), B.ITEM_CODE
    </select>
    
    <!-- 판매설정의 그리드 바디 조회 : 버전의 기간 리스트와 헤더의 조합 -->
    <select id="searchSaleSetBody" parameterType="map" resultType="map">
    SELECT /* com.hitejinro.snop.work.dao.M02020DaoMapper.searchSaleSetBody */
           A.VER_CD
         , A.STD_YYYYMMDD       -- 기준일자(실적일자)
         , C.LIQUOR_CODE, C.LIQUOR_DESC, D.PERIOD_TYPE, D.PERIOD_CODE, D.PERIOD_NAME
        <![CDATA[
         , MAX(
                CASE WHEN D.PERIOD_TYPE = 'YYYYMMDD' AND D.PERIOD_CODE <= A.STD_YYYYMMDD THEN D.PERIOD_TYPE || '_ACTUAL'
                     WHEN D.PERIOD_TYPE = 'YYYYMMDD' AND D.PERIOD_CODE >  A.STD_YYYYMMDD THEN D.PERIOD_TYPE || '_PLAN'
                     ELSE                                                                     D.PERIOD_TYPE
                END
              ) AS "Def"    -- 트리그리드의 행별 속성 설정 : YYYYMM, YYYYWW, YYYYMMDD
        ]]>
         , MAX(
                CASE WHEN D.PERIOD_TYPE = 'YYYYMM'   THEN ''
                     WHEN D.PERIOD_TYPE = 'YYYYWW'   THEN '    '
                     WHEN D.PERIOD_TYPE = 'YYYYMMDD' THEN '        '
                     ELSE                                 ''
                END
                || D.PERIOD_NAME
              ) AS PERIOD_DESC  -- 기간유형에 따라서, 들여쓰기 처리
         , D.BUSINESS_DAY_FLAG, D.PERIOD_FR_YYYYMMDD, D.PERIOD_TO_YYYYMMDD, D.PERIOD_TYPE_SEQ, MAX(D.CALENDAR_WORK_CNT) AS CALENDAR_WORK_CNT, MAX(D.WORK_CNT) AS WORK_CNT
         , MAX(CASE WHEN D.PERIOD_TYPE IN (                    'YYYYMMDD') THEN E.SALE_TYPE END)        AS SALE_TYPE        -- 사용판매량 : 공통그룹코드=USE_SALE_QTY_LIST + 실적(ACTUAL). 일자(YYYYMMDD)만 표현
         , MAX(CASE WHEN D.PERIOD_TYPE IN (                    'YYYYMMDD') THEN G.SALE_TYPE_DESC END)   AS SALE_TYPE_DESC   -- 사용판매량 명칭
         /* 제품별로 "변수 반영 전 판매량"(BF_SALE_VAR_APL_SALE_QTY), "최종 판매량"(변수반영후 or 수기입력)(SALE_QTY). 단순c/s단위.
         , SUM(CASE WHEN D.PERIOD_TYPE IN (                    'YYYYMMDD') AND E.ITEM_CODE = '10311471' THEN NVL(E.BF_SALE_VAR_APL_SALE_QTY, 0)
                    WHEN D.PERIOD_TYPE IN ('YYYYMM', 'YYYYWW'            ) AND F.ITEM_CODE = '10311471' THEN NVL(F.BF_SALE_VAR_APL_SALE_QTY, 0) END) AS COL_1_BF_SALE_VAR_APL_SALE_QTY
         , SUM(CASE WHEN D.PERIOD_TYPE IN (                    'YYYYMMDD') AND E.ITEM_CODE = '10311471' THEN NVL(E.SALE_QTY, 0)
                    WHEN D.PERIOD_TYPE IN ('YYYYMM', 'YYYYWW'            ) AND F.ITEM_CODE = '10311471' THEN NVL(F.SALE_QTY, 0)                 END) AS COL_1_SALE_QTY
         */
        <if test="TREEGRID_HEADER != '' and TREEGRID_HEADER != null">
            <foreach open="" collection="TREEGRID_HEADER" index="index" item="item" separator="" close="">
         , SUM(CASE WHEN D.PERIOD_TYPE IN (                    'YYYYMMDD') AND E.ITEM_CODE = #{item.ITEM_CODE, jdbcType=VARCHAR} THEN NVL(E.BF_SALE_VAR_APL_SALE_QTY, 0)
                    WHEN D.PERIOD_TYPE IN ('YYYYMM', 'YYYYWW'            ) AND F.ITEM_CODE = #{item.ITEM_CODE, jdbcType=VARCHAR} THEN NVL(F.BF_SALE_VAR_APL_SALE_QTY, 0) END) AS ${item.COL_ID}_BF_SALE_VAR_APL_SALE_QTY
         , SUM(CASE WHEN D.PERIOD_TYPE IN (                    'YYYYMMDD') AND E.ITEM_CODE = #{item.ITEM_CODE, jdbcType=VARCHAR} THEN NVL(E.SALE_QTY, 0)
                    WHEN D.PERIOD_TYPE IN ('YYYYMM', 'YYYYWW'            ) AND F.ITEM_CODE = #{item.ITEM_CODE, jdbcType=VARCHAR} THEN NVL(F.SALE_QTY, 0)                 END) AS ${item.COL_ID}_SALE_QTY
            </foreach>
        </if>

      FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_M       A
      JOIN EDW.W_CM_TB_LIQUOR_M                 C
        ON C.LIQUOR_CODE = #{liquorCode, jdbcType=VARCHAR}
 LEFT JOIN (    -- D. 버전의 유효기간에 해당하는 날짜 리스트(월, 연주차, 일자)
                SELECT DB.VER_CD, DC.PERIOD_TYPE
                     , CASE WHEN DC.PERIOD_TYPE = 'YYYYMM'   THEN DA.YYYYMM
                            WHEN DC.PERIOD_TYPE = 'YYYYWW'   THEN DA.SCM_YYYYWW
                            WHEN DC.PERIOD_TYPE = 'YYYYMMDD' THEN DA.YYYYMMDD
                       END                  AS PERIOD_CODE
                     , CASE WHEN DC.PERIOD_TYPE = 'YYYYMM'   THEN MAX( SUBSTR(DA.YYYYMM, 1, 4) || '-' || SUBSTR(DA.YYYYMM, 5, 2) || '월' )
                            WHEN DC.PERIOD_TYPE = 'YYYYWW'   THEN MAX( SUBSTR(DA.SCM_YYYYWW, 1, 4) || '년 ' || SUBSTR(DA.SCM_YYYYWW, 5, 2) || '주차' ) || '(' || MIN(TO_CHAR(TO_DATE(DA.YYYYMMDD, 'YYYYMMDD'), 'MM/DD')) || '~' || MAX(TO_CHAR(TO_DATE(DA.YYYYMMDD, 'YYYYMMDD'), 'MM/DD')) || ')'
                            WHEN DC.PERIOD_TYPE = 'YYYYMMDD' THEN MAX( TO_CHAR(TO_DATE(DA.YYYYMMDD, 'YYYYMMDD'), 'YYYY-MM-DD') || ' (' || DA.DAY_OF_WEEK_DESC || ')' )
                       END                  AS PERIOD_NAME
                     , CASE WHEN DC.PERIOD_TYPE = 'YYYYMM'   THEN TO_CHAR(NULL)
                            WHEN DC.PERIOD_TYPE = 'YYYYWW'   THEN TO_CHAR(NULL)
                            WHEN DC.PERIOD_TYPE = 'YYYYMMDD' THEN MAX(DA.BUSINESS_DAY_FLAG)
                       END                  AS BUSINESS_DAY_FLAG
                     , MIN(DA.YYYYMMDD)     AS PERIOD_FR_YYYYMMDD
                     , MAX(DA.YYYYMMDD)     AS PERIOD_TO_YYYYMMDD
                     , MAX(DC.SEQ)          AS PERIOD_TYPE_SEQ
                     , CASE WHEN DC.PERIOD_TYPE = 'YYYYMM'   THEN MAX( DA.YYYYMM_WORK_CNT )
                            WHEN DC.PERIOD_TYPE = 'YYYYWW'   THEN MAX( DA.SCM_YYYYWW_WORK_CNT )
                            WHEN DC.PERIOD_TYPE = 'YYYYMMDD' THEN 1
                       END                  AS CALENDAR_WORK_CNT -- 기간의 영업일수 : 실제 달력상의 영업일수(월의 시작/종료 주차에서 일자가 잘려도 무시 )
                     , SUM(CASE WHEN DA.BUSINESS_DAY_FLAG = 'Y' THEN 1 ELSE 0 END) AS WORK_CNT -- 기간의 영업일수 : 월의 시작/종료 주차의 경우, 해당 월에 포함된 날짜만 계산
                     
                  FROM SCMU.W_SOP_VW_CALENDAR_M       DA
                  JOIN SCMU.W_SOP_TB_DALY_SCM_SIMUL_M DB
                    ON DA.YYYYMMDD BETWEEN DB.VER_FR_DT AND DB.VER_TO_DT
            CROSS JOIN (
                            SELECT 'YYYYMM'   AS PERIOD_TYPE, 1 AS SEQ FROM DUAL UNION ALL
                            SELECT 'YYYYWW'   AS PERIOD_TYPE, 2 AS SEQ FROM DUAL UNION ALL
                            SELECT 'YYYYMMDD' AS PERIOD_TYPE, 3 AS SEQ FROM DUAL
                       )                              DC
                 WHERE 1 = 1
                   AND DB.VER_CD = #{verCd, jdbcType=VARCHAR}
                 GROUP BY DB.VER_CD, DC.PERIOD_TYPE
                        , CASE WHEN DC.PERIOD_TYPE = 'YYYYMM'   THEN DA.YYYYMM
                               WHEN DC.PERIOD_TYPE = 'YYYYWW'   THEN DA.SCM_YYYYWW
                               WHEN DC.PERIOD_TYPE = 'YYYYMMDD' THEN DA.YYYYMMDD
                          END
           )                                    D
        ON D.VER_CD = A.VER_CD
 LEFT JOIN SCMU.W_SOP_TB_DALY_SCM_SIMUL_SALE_F  E -- E. 판매설정 중 일자(YYYYMMDD)의 "사용판매량"(SALE_TYPE), "변수 반영 전 판매량"(BF_SALE_VAR_APL_SALE_QTY), "최종 판매량"(변수반영후 or 수기입력)(SALE_QTY) 조회
        ON E.VER_CD          = A.VER_CD
       AND E.ITEM_MAP_YN     = 'Y' -- 제품매핑여부=Y : N은 검증용이니, 실제 사용하는 Y(모제품 매핑 후)를 사용
       AND E.LIQUOR_CODE     = C.LIQUOR_CODE
       AND 'YYYYMMDD'        = D.PERIOD_TYPE
       AND E.PERIOD_YYYYMMDD = D.PERIOD_CODE
 LEFT JOIN SCMU.W_SOP_TB_DALY_SCM_SIMUL_SALE_F  F -- F. 판매설정 중 월(YYYYMM), 주차(YYYYWW)의 "변수 반영 전 판매량"(BF_SALE_VAR_APL_SALE_QTY), "최종 판매량"(변수반영후 or 수기입력)(SALE_QTY) 조회 : 하위 일자(YYYYMMDD)의 합산
        ON F.VER_CD          = A.VER_CD
       AND F.ITEM_MAP_YN     = 'Y' -- 제품매핑여부=Y : N은 검증용이니, 실제 사용하는 Y(모제품 매핑 후)를 사용
       AND F.LIQUOR_CODE     = C.LIQUOR_CODE
       AND F.PERIOD_YYYYMMDD BETWEEN D.PERIOD_FR_YYYYMMDD AND D.PERIOD_TO_YYYYMMDD
       AND D.PERIOD_TYPE     IN ('YYYYMM', 'YYYYWW')
 LEFT JOIN (
                SELECT CODE AS SALE_TYPE, NAME AS SALE_TYPE_DESC
                  FROM SCMU.W_SOP_TB_COM_CODE_M
                 WHERE 1 = 1
                   AND GROUP_CODE = 'USE_SALE_QTY_LIST'
                 UNION ALL
                SELECT 'ACTUAL' AS SALE_TYPE, '실적' AS SALE_TYPE_DESC FROM DUAL
           )                                    G -- G. 사용판매량의 명칭 조회 : 공통그룹코드=USE_SALE_QTY_LIST + 실적(ACTUAL)
        ON G.SALE_TYPE = E.SALE_TYPE
     WHERE 1 = 1
       AND A.VER_CD = #{verCd, jdbcType=VARCHAR}
     GROUP BY A.VER_CD, A.STD_YYYYMMDD, C.LIQUOR_CODE, C.LIQUOR_DESC, D.PERIOD_TYPE, D.PERIOD_CODE, D.PERIOD_NAME, D.BUSINESS_DAY_FLAG, D.PERIOD_FR_YYYYMMDD, D.PERIOD_TO_YYYYMMDD, D.PERIOD_TYPE_SEQ
     ORDER BY C.LIQUOR_CODE, D.PERIOD_FR_YYYYMMDD, D.PERIOD_TYPE_SEQ, D.PERIOD_CODE
    </select>
    
    <!-- 판매설정 데이터 저장 : 일자별 제품의 판매량 변경(수기입력) 저장 -->
    <update id="updateSaleSet" parameterType="map">
MERGE /* com.hitejinro.snop.work.dao.M02020DaoMapper.updateSaleSet */
 INTO SCMU.W_SOP_TB_DALY_SCM_SIMUL_SALE_F T
USING (
            SELECT SA.VER_CD, 'Y' AS ITEM_MAP_YN, SA.LIQUOR_CODE, SA.PERIOD_CODE AS PERIOD_YYYYMMDD, SA.ITEM_CODE
                 , SA.SALE_QTY
                 , 0 AS BF_SALE_VAR_APL_SALE_QTY, 0 AS AF_SALE_VAR_APL_SALE_QTY, 'Y' AS MODIFY_YN, TO_CHAR(NULL) AS SALE_TYPE, TO_NUMBER(NULL) AS SALE_VAR_DFNT_SEQNO, TO_NUMBER(NULL) AS SALE_VAR_VAL
                 , NULL AS ATTRIBUTE1, NULL AS ATTRIBUTE2, NULL AS ATTRIBUTE3, NULL AS ATTRIBUTE4, NULL AS ATTRIBUTE5
                 
              FROM (
        <foreach collection="updateList" item="list" separator="UNION ALL" index="i">
SELECT #{list.VER_CD, jdbcType=VARCHAR}                                                                     AS VER_CD
     , #{list.LIQUOR_CODE, jdbcType=VARCHAR}                                                                AS LIQUOR_CODE
     , #{list.PERIOD_TYPE, jdbcType=VARCHAR}                                                                AS PERIOD_TYPE
     , #{list.PERIOD_CODE, jdbcType=VARCHAR}                                                                AS PERIOD_CODE
     , #{list.ITEM_CODE, jdbcType=VARCHAR}                                                                  AS ITEM_CODE
     , NVL(TO_NUMBER(#{list.SALE_QTY, jdbcType=VARCHAR}), 0)                                                AS SALE_QTY
     
     , #{list.action, jdbcType=VARCHAR}                                                                     AS ROW_ACTION   -- 행 상태 : insert, update, delete
     , ROWNUM                                                                                               AS RNUM
  FROM DUAL
        </foreach>
                   )                                    SA
             WHERE 1 = 1
      ) S
   ON (T.VER_CD = S.VER_CD AND T.ITEM_MAP_YN = S.ITEM_MAP_YN AND T.LIQUOR_CODE = S.LIQUOR_CODE AND T.PERIOD_YYYYMMDD = S.PERIOD_YYYYMMDD AND T.ITEM_CODE = S.ITEM_CODE)
 WHEN MATCHED THEN
    UPDATE
       SET T.SALE_QTY           = S.SALE_QTY
         , T.MODIFY_YN          = S.MODIFY_YN   -- Y로 고정
         , T.RMKS               = T.RMKS || ' => ' || '수기입력(' || TRIM(TO_CHAR(S.SALE_QTY, '9,999,999,999.9')) || ')' -- 수기변경값 표현
         , T.LAST_UPDATED_BY    = #{userId, jdbcType=VARCHAR}
         , T.LAST_UPDATE_DATE   = SYSDATE
 
 WHEN NOT MATCHED THEN
    INSERT (T.VER_CD, T.ITEM_MAP_YN, T.LIQUOR_CODE, T.PERIOD_YYYYMMDD, T.ITEM_CODE
            , T.SALE_QTY, T.BF_SALE_VAR_APL_SALE_QTY, T.AF_SALE_VAR_APL_SALE_QTY, T.MODIFY_YN, T.SALE_TYPE, T.SALE_VAR_DFNT_SEQNO, T.SALE_VAR_VAL
            , T.RMKS
            , T.ATTRIBUTE1, T.ATTRIBUTE2, T.ATTRIBUTE3, T.ATTRIBUTE4, T.ATTRIBUTE5, T.CREATED_BY, T.CREATION_DATE, T.LAST_UPDATED_BY, T.LAST_UPDATE_DATE)
    VALUES (S.VER_CD, S.ITEM_MAP_YN, S.LIQUOR_CODE, S.PERIOD_YYYYMMDD, S.ITEM_CODE
            , S.SALE_QTY, S.BF_SALE_VAR_APL_SALE_QTY, S.AF_SALE_VAR_APL_SALE_QTY, S.MODIFY_YN, S.SALE_TYPE, S.SALE_VAR_DFNT_SEQNO, S.SALE_VAR_VAL
            , '수기입력(' || S.SALE_QTY || ')'
            , S.ATTRIBUTE1, S.ATTRIBUTE2, S.ATTRIBUTE3, S.ATTRIBUTE4, S.ATTRIBUTE5, #{userId, jdbcType=VARCHAR}, SYSDATE, #{userId, jdbcType=VARCHAR}, SYSDATE)
    </update>


    <!-- 판매설정 - 사용판매량/실적반영유형 조회 -->
    <select id="searchUseSaleQtyActualRfltType" parameterType="map" resultType="map">
    SELECT /* com.hitejinro.snop.work.dao.M02020DaoMapper.searchUseSaleQtyActualRfltType */
           A.VER_CD, B.LIQUOR_CODE, B.LIQUOR_DESC
         , C.CODE AS SALE_SET_TYPE_CODE
         --, C.NAME AS SALE_SET_TYPE_NAME
         , E.SEQNO
         , D.PERIOD_CODE AS USE_SALE_QTY_YYYYMM
         , D.PERIOD_NAME AS USE_SALE_QTY_YYYYMM_DESC
         , E.VAL    AS USE_SALE_QTY_VAL     -- 사용판매량(공통그룹코드=USE_SALE_QTY_LIST) : YYYY_TRG(경영계획), SALE_PLAN(판매계획), ESPN_SALE(예상판매량)
         , CASE WHEN D.PERIOD_CODE = SUBSTR(A.STD_YYYYMMDD, 1, 6) THEN F.VAL
                ELSE                                                NULL
           END      AS ACTUAL_RFLT_TYPE_VAL -- 실적반영유형(공통그룹코드=ACTUAL_RFLT_TYPE_LIST) :기준일자(실적일자)의 년월에만 생성 : DIST_EQUAL(균등), DIST_DIFF(차액배분)
         
      FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_M           A
      JOIN EDW.W_CM_TB_LIQUOR_M                     B
        ON B.LIQUOR_CODE IN ('10', '20') -- 맥주(10), 소주(20)만 대상
      JOIN SCMU.W_SOP_TB_COM_CODE_M                 C
        ON C.GROUP_CODE = 'SALE_SET_TYPE'
       AND C.CODE       = 'USE_SALE_QTY' -- "사용판매량" 로 고정
 LEFT JOIN (    -- D. 버전의 유효기간에 해당하는 날짜 리스트(월)
                SELECT DB.VER_CD, DC.PERIOD_TYPE
                     , CASE WHEN DC.PERIOD_TYPE = 'YYYYMM'   THEN DA.YYYYMM
                            WHEN DC.PERIOD_TYPE = 'YYYYWW'   THEN DA.SCM_YYYYWW
                            WHEN DC.PERIOD_TYPE = 'YYYYMMDD' THEN DA.YYYYMMDD
                       END                  AS PERIOD_CODE
                     , CASE WHEN DC.PERIOD_TYPE = 'YYYYMM'   THEN MAX( SUBSTR(DA.YYYYMM, 1, 4) || '-' || SUBSTR(DA.YYYYMM, 5, 2) || '월' )
                            WHEN DC.PERIOD_TYPE = 'YYYYWW'   THEN MAX( SUBSTR(DA.SCM_YYYYWW, 1, 4) || '년 ' || SUBSTR(DA.SCM_YYYYWW, 5, 2) || '주차' ) || '(' || MIN(TO_CHAR(TO_DATE(DA.YYYYMMDD, 'YYYYMMDD'), 'MM/DD')) || '~' || MAX(TO_CHAR(TO_DATE(DA.YYYYMMDD, 'YYYYMMDD'), 'MM/DD')) || ')'
                            WHEN DC.PERIOD_TYPE = 'YYYYMMDD' THEN MAX( TO_CHAR(TO_DATE(DA.YYYYMMDD, 'YYYYMMDD'), 'YYYY-MM-DD') || ' (' || DA.DAY_OF_WEEK_DESC || ')' )
                       END                  AS PERIOD_NAME
                     , CASE WHEN DC.PERIOD_TYPE = 'YYYYMM'   THEN TO_CHAR(NULL)
                            WHEN DC.PERIOD_TYPE = 'YYYYWW'   THEN TO_CHAR(NULL)
                            WHEN DC.PERIOD_TYPE = 'YYYYMMDD' THEN MAX(DA.BUSINESS_DAY_FLAG)
                       END                  AS BUSINESS_DAY_FLAG
                     , MIN(DA.YYYYMMDD)     AS PERIOD_FR_YYYYMMDD
                     , MAX(DA.YYYYMMDD)     AS PERIOD_TO_YYYYMMDD
                     , MAX(DC.SEQ)          AS PERIOD_TYPE_SEQ
                     , CASE WHEN DC.PERIOD_TYPE = 'YYYYMM'   THEN MAX( DA.YYYYMM_WORK_CNT )
                            WHEN DC.PERIOD_TYPE = 'YYYYWW'   THEN MAX( DA.SCM_YYYYWW_WORK_CNT )
                            WHEN DC.PERIOD_TYPE = 'YYYYMMDD' THEN 1
                       END                  AS CALENDAR_WORK_CNT -- 기간의 영업일수 : 실제 달력상의 영업일수(월의 시작/종료 주차에서 일자가 잘려도 무시 )
                     , SUM(CASE WHEN DA.BUSINESS_DAY_FLAG = 'Y' THEN 1 ELSE 0 END) AS WORK_CNT -- 기간의 영업일수 : 월의 시작/종료 주차의 경우, 해당 월에 포함된 날짜만 계산
                     
                  FROM SCMU.W_SOP_VW_CALENDAR_M       DA
                  JOIN SCMU.W_SOP_TB_DALY_SCM_SIMUL_M DB
                    ON DA.YYYYMMDD BETWEEN DB.VER_FR_DT AND DB.VER_TO_DT
            CROSS JOIN (
                            SELECT 'YYYYMM'   AS PERIOD_TYPE, 1 AS SEQ FROM DUAL
                       )                              DC
                 WHERE 1 = 1
                   AND DB.VER_CD = #{verCd, jdbcType=VARCHAR}
                 GROUP BY DB.VER_CD, DC.PERIOD_TYPE
                        , CASE WHEN DC.PERIOD_TYPE = 'YYYYMM'   THEN DA.YYYYMM
                               WHEN DC.PERIOD_TYPE = 'YYYYWW'   THEN DA.SCM_YYYYWW
                               WHEN DC.PERIOD_TYPE = 'YYYYMMDD' THEN DA.YYYYMMDD
                          END
           )                                    D
        ON D.VER_CD = A.VER_CD
            -- E. 월별 사용판매량 리스트
 LEFT JOIN SCMU.W_SOP_TB_DALY_SCM_SIMUL_SALE_SET_M  E
        ON E.VER_CD              = A.VER_CD
       AND E.LIQUOR_CODE         = B.LIQUOR_CODE
       AND E.SALE_SET_TYPE_CODE  = C.CODE -- "사용판매량"(USE_SALE_QTY) 로 고정
       AND E.USE_SALE_QTY_YYYYMM = D.PERIOD_CODE
            -- F. 실적월(기준일자가 포함된 월)의 실적반영유형(ACTUAL_RFLT_TYPE) : DIST_EQUAL(균등), DIST_DIFF(차액배분)
 LEFT JOIN SCMU.W_SOP_TB_DALY_SCM_SIMUL_SALE_SET_M  F
        ON F.VER_CD              = A.VER_CD
       AND F.LIQUOR_CODE         = B.LIQUOR_CODE
       AND F.SALE_SET_TYPE_CODE  = 'ACTUAL_RFLT_TYPE' -- 실적반영유형(ACTUAL_RFLT_TYPE)
     WHERE 1 = 1
       AND A.VER_CD      = #{verCd, jdbcType=VARCHAR}
       AND B.LIQUOR_CODE = #{liquorCode, jdbcType=VARCHAR}
     ORDER BY A.VER_CD, C.CODE, B.LIQUOR_CODE, D.PERIOD_CODE
    </select>
    
    <!-- 판매설정 - 사용판매량 저장(추가/수정) -->
    <update id="updateUseSaleQty" parameterType="map">
MERGE /* com.hitejinro.snop.work.dao.M02020DaoMapper.updateUseSaleQty */
 INTO SCMU.W_SOP_TB_DALY_SCM_SIMUL_SALE_SET_M T
USING (
        SELECT #{VER_CD, jdbcType=VARCHAR}                                                                      AS VER_CD
             , #{LIQUOR_CODE, jdbcType=VARCHAR}                                                                 AS LIQUOR_CODE
             , 'USE_SALE_QTY'                                                                                   AS SALE_SET_TYPE_CODE -- "사용판매량"(USE_SALE_QTY) 로 고정
             , NVL(TO_NUMBER(#{SEQNO, jdbcType=VARCHAR}), 0)                                                    AS SEQNO
             , #{USE_SALE_QTY_VAL, jdbcType=VARCHAR}                                                            AS USE_SALE_QTY_VAL
             , #{USE_SALE_QTY_YYYYMM, jdbcType=VARCHAR}                                                         AS USE_SALE_QTY_YYYYMM
             , NULL AS ATTRIBUTE1, NULL AS ATTRIBUTE2, NULL AS ATTRIBUTE3, NULL AS ATTRIBUTE4, NULL AS ATTRIBUTE5
          FROM DUAL
      ) S
   ON (T.VER_CD = S.VER_CD AND T.LIQUOR_CODE = S.LIQUOR_CODE AND T.SALE_SET_TYPE_CODE = S.SALE_SET_TYPE_CODE AND T.SEQNO = S.SEQNO)
 WHEN MATCHED THEN
    UPDATE
       SET T.VAL                = S.USE_SALE_QTY_VAL
         , T.LAST_UPDATED_BY    = #{userId, jdbcType=VARCHAR}
         , T.LAST_UPDATE_DATE   = SYSDATE
 
 WHEN NOT MATCHED THEN
    INSERT (T.VER_CD, T.LIQUOR_CODE, T.SALE_SET_TYPE_CODE, T.SEQNO
            , T.VAL
            , T.DOW_CODE
            , T.USE_SALE_QTY_YYYYMM
            , T.SALE_VAR_APL_FR_DT, T.SALE_VAR_APL_TO_DT, T.SALE_VAR_NAME, T.SALE_VAR_TYPE, T.SALE_VAR_USAGE_CODE, T.SALE_VAR_ITEM_CODE, T.SALE_VAR_VAL
            , T.RMKS, T.ATTRIBUTE1, T.ATTRIBUTE2, T.ATTRIBUTE3, T.ATTRIBUTE4, T.ATTRIBUTE5, T.CREATED_BY, T.CREATION_DATE, T.LAST_UPDATED_BY, T.LAST_UPDATE_DATE)
    VALUES (S.VER_CD, S.LIQUOR_CODE, S.SALE_SET_TYPE_CODE, (SELECT NVL(MAX(SEQNO), 0)+1 FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_SALE_SET_M WHERE VER_CD = S.VER_CD AND LIQUOR_CODE = S.LIQUOR_CODE AND SALE_SET_TYPE_CODE = 'USE_SALE_QTY')
            , S.USE_SALE_QTY_VAL
            , NULL
            , S.USE_SALE_QTY_YYYYMM
            , NULL, NULL, NULL, NULL, NULL, NULL, NULL
            , NULL, S.ATTRIBUTE1, S.ATTRIBUTE2, S.ATTRIBUTE3, S.ATTRIBUTE4, S.ATTRIBUTE5, #{userId, jdbcType=VARCHAR}, SYSDATE, #{userId, jdbcType=VARCHAR}, SYSDATE)
    </update>
    
    <!-- 판매설정 - 사용판매량 저장(삭제) : 버전이 허용한 기간을 벗어난 것은 삭제 -->
    <delete id="deleteUseSaleQty" parameterType="map">
DELETE /* com.hitejinro.snop.work.dao.M02020DaoMapper.deleteUseSaleQty */
  FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_SALE_SET_M T
 WHERE 1 = 1
   AND T.VER_CD             = #{verCd, jdbcType=VARCHAR}
   AND T.SALE_SET_TYPE_CODE = 'USE_SALE_QTY' -- "사용판매량"(USE_SALE_QTY) 로 고정
   AND NOT EXISTS (
                    SELECT 1
                      FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_M X
                     WHERE 1 = 1
                       AND X.VER_CD              = #{verCd, jdbcType=VARCHAR}
                       AND T.USE_SALE_QTY_YYYYMM BETWEEN SUBSTR(X.VER_FR_DT, 1, 6) AND SUBSTR(X.VER_TO_DT, 1, 6)
       )
    </delete>
    
    <!-- 판매설정 - 실적반영유형 저장(추가/수정) -->
    <update id="updateActualRfltType" parameterType="map">
MERGE /* com.hitejinro.snop.work.dao.M02020DaoMapper.updateActualRfltType */
 INTO SCMU.W_SOP_TB_DALY_SCM_SIMUL_SALE_SET_M T
USING (
        SELECT #{VER_CD, jdbcType=VARCHAR}                                                                      AS VER_CD
             , #{LIQUOR_CODE, jdbcType=VARCHAR}                                                                 AS LIQUOR_CODE
             , 'ACTUAL_RFLT_TYPE'                                                                               AS SALE_SET_TYPE_CODE   -- 실적반영유형(ACTUAL_RFLT_TYPE)
             , 1                                                                                                AS SEQNO                -- 실적반영유형은 사업부문별로 하나만 존재하므로, 1로 고정
             , #{ACTUAL_RFLT_TYPE_VAL, jdbcType=VARCHAR}                                                        AS ACTUAL_RFLT_TYPE_VAL -- 실적반영유형(공통그룹코드=ACTUAL_RFLT_TYPE_LIST) : DIST_EQUAL(균등), DIST_DIFF(차액배분)
             , NULL AS ATTRIBUTE1, NULL AS ATTRIBUTE2, NULL AS ATTRIBUTE3, NULL AS ATTRIBUTE4, NULL AS ATTRIBUTE5
          FROM DUAL
      ) S
   ON (T.VER_CD = S.VER_CD AND T.LIQUOR_CODE = S.LIQUOR_CODE AND T.SALE_SET_TYPE_CODE = S.SALE_SET_TYPE_CODE AND T.SEQNO = S.SEQNO)
 WHEN MATCHED THEN
    UPDATE
       SET T.VAL                = S.ACTUAL_RFLT_TYPE_VAL
         , T.LAST_UPDATED_BY    = #{userId, jdbcType=VARCHAR}
         , T.LAST_UPDATE_DATE   = SYSDATE
 
 WHEN NOT MATCHED THEN
    INSERT (T.VER_CD, T.LIQUOR_CODE, T.SALE_SET_TYPE_CODE, T.SEQNO
            , T.VAL
            , T.DOW_CODE, T.USE_SALE_QTY_YYYYMM, T.SALE_VAR_APL_FR_DT, T.SALE_VAR_APL_TO_DT, T.SALE_VAR_NAME, T.SALE_VAR_TYPE, T.SALE_VAR_USAGE_CODE, T.SALE_VAR_ITEM_CODE, T.SALE_VAR_VAL
            , T.RMKS, T.ATTRIBUTE1, T.ATTRIBUTE2, T.ATTRIBUTE3, T.ATTRIBUTE4, T.ATTRIBUTE5, T.CREATED_BY, T.CREATION_DATE, T.LAST_UPDATED_BY, T.LAST_UPDATE_DATE)
    VALUES (S.VER_CD, S.LIQUOR_CODE, S.SALE_SET_TYPE_CODE, S.SEQNO
            , S.ACTUAL_RFLT_TYPE_VAL
            , NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
            , NULL, S.ATTRIBUTE1, S.ATTRIBUTE2, S.ATTRIBUTE3, S.ATTRIBUTE4, S.ATTRIBUTE5, #{userId, jdbcType=VARCHAR}, SYSDATE, #{userId, jdbcType=VARCHAR}, SYSDATE)
    </update>


    <!-- 판매설정 - 판매변수 조회 -->
    <select id="searchSaleVar" parameterType="map" resultType="map">
    SELECT /* com.hitejinro.snop.work.dao.M02020DaoMapper.searchSaleVar */
           A.VER_CD
         , B.CODE AS SALE_SET_TYPE_CODE
         --, B.NAME AS SALE_SET_TYPE_NAME
         , C.SEQNO
         , C.SALE_VAR_APL_FR_DT, C.SALE_VAR_APL_TO_DT
         , C.VAL                                        AS SALE_VAR_DFNT_SEQNO      -- 판매변수의 일련번호
         , '[' || C.VAL || ']' || C.SALE_VAR_NAME       AS SALE_VAR_DFNT_SEQNO_NAME -- 판매변수의 일련번호 + 명칭
         , C.SALE_VAR_VAL                                                           -- 판매변수의 변수값 : 저장된 값으로 View. 실제 판매변수(W_SOP_TB_SALE_VAR_DFNT_F)에 등록된 값과 다를 수 있음
         -- 판매변수를 적용할 대상 : 사업부문, 용도, 제품
         , C.LIQUOR_CODE
         , NVL(DA.LIQUOR_DESC, C.LIQUOR_CODE)           AS LIQUOR_DESC
         , NVL(DB.USAGE_NAME, C.SALE_VAR_USAGE_CODE)    AS SALE_VAR_USAGE_NAME
         , CASE WHEN C.SALE_VAR_ITEM_CODE = '!ALL' THEN '전체'
                ELSE                                    NVL(DC.DESCRIPTION, C.SALE_VAR_ITEM_CODE)
           END                                          AS SALE_VAR_ITEM_NAME
         , C.SALE_VAR_NAME, C.SALE_VAR_TYPE, C.SALE_VAR_USAGE_CODE, C.SALE_VAR_ITEM_CODE
         -- 실제 판매변수(W_SOP_TB_SALE_VAR_DFNT_F)와 비교
         , CASE WHEN C.VAL IS NULL                  THEN TO_CHAR(NULL)
                WHEN E.SALE_VAR_DFNT_SEQNO IS NULL  THEN '현재 존재하지 않는 판매변수'
                ELSE SUBSTR(CASE WHEN NVL(C.SALE_VAR_TYPE, '^') != E.SALE_VAR_TYPE          THEN ', ' || '판매변수 유형 다름' END
                            || CASE WHEN NVL(C.SALE_VAR_NAME, '^') != E.SALE_VAR_NAME       THEN ', ' || '판매변수 명칭 다름' END
                            || CASE WHEN NVL(C.LIQUOR_CODE, '^') != E.LIQUOR_CODE           THEN ', ' || '대상 사업부문 다름' END
                            || CASE WHEN NVL(C.SALE_VAR_USAGE_CODE, '^') != E.USAGE_CODE    THEN ', ' || '대상 용도 다름' END
                            || CASE WHEN NVL(C.SALE_VAR_ITEM_CODE, '^') != E.ITEM_CODE      THEN ', ' || '대상 제품 다름' END
                            || CASE WHEN NVL(C.SALE_VAR_VAL, 0) != E.VAR_VAL                THEN ', ' || '변수값 다름' END
                            , 3)
           END                                          AS SALE_VAR_VALID_MSG
         
      FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_M           A
      JOIN SCMU.W_SOP_TB_COM_CODE_M                 B
        ON B.GROUP_CODE = 'SALE_SET_TYPE'
       AND B.CODE       = 'SALE_VAR' -- "판매변수" 로 고정
      JOIN SCMU.W_SOP_TB_DALY_SCM_SIMUL_SALE_SET_M  C
        ON C.VER_CD             = A.VER_CD
       AND C.SALE_SET_TYPE_CODE = B.CODE
 LEFT JOIN EDW.W_CM_TB_LIQUOR_M                     DA
        ON DA.LIQUOR_CODE = C.LIQUOR_CODE
 LEFT JOIN (
                SELECT '!ALL' AS USAGE_CODE, '전체' AS USAGE_NAME FROM DUAL
                 UNION ALL
                SELECT USAGE_CODE, MAX(USAGE_NAME) AS USAGE_NAME
                  FROM EDW.W_CM_TB_FG_ITEM_M
                 WHERE 1 = 1
                   AND ITEM_TYPE  = 'FG'
                   AND USAGE_CODE IS NOT NULL
                 GROUP BY USAGE_CODE
           )                                        DB
        ON DB.USAGE_CODE = C.SALE_VAR_USAGE_CODE
 LEFT JOIN EDW.W_CM_TB_FG_ITEM_M                    DC
        ON DC.ITEM_CODE = C.SALE_VAR_ITEM_CODE
 LEFT JOIN SCMU.W_SOP_TB_SALE_VAR_DFNT_F            E
        ON TO_CHAR(E.SALE_VAR_DFNT_SEQNO) = C.VAL
     WHERE 1 = 1
       AND A.VER_CD = #{verCd, jdbcType=VARCHAR}
     ORDER BY A.VER_CD, B.CODE, C.SALE_VAR_APL_FR_DT, C.SALE_VAR_NAME, C.LIQUOR_CODE, C.SEQNO
    </select>

    <!-- 판매설정 - 판매변수 저장(추가/수정) -->
    <update id="updateSaleVar" parameterType="map">
MERGE /* com.hitejinro.snop.work.dao.M02020DaoMapper.updateSaleVar */
 INTO SCMU.W_SOP_TB_DALY_SCM_SIMUL_SALE_SET_M T
USING (
            SELECT SA.VER_CD, SB.LIQUOR_CODE, SA.SALE_SET_TYPE_CODE, SA.SEQNO
                 , SA.SALE_VAR_DFNT_SEQNO
                 , SA.SALE_VAR_APL_FR_DT, SA.SALE_VAR_APL_TO_DT
                 , SB.SALE_VAR_NAME, SB.SALE_VAR_TYPE, SB.USAGE_CODE AS SALE_VAR_USAGE_CODE, SB.ITEM_CODE AS SALE_VAR_ITEM_CODE, SB.VAR_VAL AS SALE_VAR_VAL
                 , NULL AS ATTRIBUTE1, NULL AS ATTRIBUTE2, NULL AS ATTRIBUTE3, NULL AS ATTRIBUTE4, NULL AS ATTRIBUTE5
              FROM (
                        SELECT #{VER_CD, jdbcType=VARCHAR}                                                                      AS VER_CD
                             , 'SALE_VAR'                                                                                       AS SALE_SET_TYPE_CODE   -- "판매변수"(SALE_VAR) 로 고정
                             , NVL(TO_NUMBER(#{SEQNO, jdbcType=VARCHAR}), 0)                                                    AS SEQNO
                             , #{SALE_VAR_DFNT_SEQNO, jdbcType=VARCHAR}                                                         AS SALE_VAR_DFNT_SEQNO  -- 판매변수의 일련번호
                             , #{SALE_VAR_APL_FR_DT, jdbcType=VARCHAR}                                                          AS SALE_VAR_APL_FR_DT
                             , #{SALE_VAR_APL_TO_DT, jdbcType=VARCHAR}                                                          AS SALE_VAR_APL_TO_DT
                          FROM DUAL
                   )                             SA
         LEFT JOIN SCMU.W_SOP_TB_SALE_VAR_DFNT_F SB
                ON TO_CHAR(SB.SALE_VAR_DFNT_SEQNO) = SA.SALE_VAR_DFNT_SEQNO
             WHERE 1 = 1
      ) S
   ON (T.VER_CD = S.VER_CD AND T.LIQUOR_CODE = S.LIQUOR_CODE AND T.SALE_SET_TYPE_CODE = S.SALE_SET_TYPE_CODE AND T.SEQNO = S.SEQNO)
 WHEN MATCHED THEN
    UPDATE
       SET T.VAL                    = TO_CHAR(S.SALE_VAR_DFNT_SEQNO)
         , T.SALE_VAR_APL_FR_DT     = S.SALE_VAR_APL_FR_DT
         , T.SALE_VAR_APL_TO_DT     = S.SALE_VAR_APL_TO_DT
         , T.SALE_VAR_NAME          = S.SALE_VAR_NAME
         , T.SALE_VAR_TYPE          = S.SALE_VAR_TYPE
         , T.SALE_VAR_USAGE_CODE    = S.SALE_VAR_USAGE_CODE
         , T.SALE_VAR_ITEM_CODE     = S.SALE_VAR_ITEM_CODE
         , T.SALE_VAR_VAL           = S.SALE_VAR_VAL
         , T.LAST_UPDATED_BY        = #{userId, jdbcType=VARCHAR}
         , T.LAST_UPDATE_DATE       = SYSDATE
 
 WHEN NOT MATCHED THEN
    INSERT (T.VER_CD, T.LIQUOR_CODE, T.SALE_SET_TYPE_CODE, T.SEQNO
            , T.VAL
            , T.DOW_CODE, T.USE_SALE_QTY_YYYYMM
            , T.SALE_VAR_APL_FR_DT, T.SALE_VAR_APL_TO_DT, T.SALE_VAR_NAME, T.SALE_VAR_TYPE, T.SALE_VAR_USAGE_CODE, T.SALE_VAR_ITEM_CODE, T.SALE_VAR_VAL
            , T.RMKS, T.ATTRIBUTE1, T.ATTRIBUTE2, T.ATTRIBUTE3, T.ATTRIBUTE4, T.ATTRIBUTE5, T.CREATED_BY, T.CREATION_DATE, T.LAST_UPDATED_BY, T.LAST_UPDATE_DATE)
    VALUES (S.VER_CD, S.LIQUOR_CODE, S.SALE_SET_TYPE_CODE, (SELECT NVL(MAX(SEQNO), 0)+1 FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_SALE_SET_M WHERE VER_CD = S.VER_CD AND LIQUOR_CODE = S.LIQUOR_CODE AND SALE_SET_TYPE_CODE = 'SALE_VAR')
            , TO_CHAR(S.SALE_VAR_DFNT_SEQNO)
            , NULL, NULL
            , S.SALE_VAR_APL_FR_DT, S.SALE_VAR_APL_TO_DT, S.SALE_VAR_NAME, S.SALE_VAR_TYPE, S.SALE_VAR_USAGE_CODE, S.SALE_VAR_ITEM_CODE, S.SALE_VAR_VAL
            , NULL, S.ATTRIBUTE1, S.ATTRIBUTE2, S.ATTRIBUTE3, S.ATTRIBUTE4, S.ATTRIBUTE5, #{userId, jdbcType=VARCHAR}, SYSDATE, #{userId, jdbcType=VARCHAR}, SYSDATE)
    </update>
    
    <!-- 판매설정 - 판매변수 저장(삭제) -->
    <delete id="deleteSaleVar" parameterType="map">
DELETE /* com.hitejinro.snop.work.dao.M02020DaoMapper.deleteSaleVar */
  FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_SALE_SET_M T
 WHERE 1 = 1
   AND T.VER_CD             = #{verCd, jdbcType=VARCHAR}
   AND T.LIQUOR_CODE        = #{LIQUOR_CODE, jdbcType=VARCHAR}
   AND T.SALE_SET_TYPE_CODE = 'SALE_VAR' -- "판매변수" 로 고정
   AND T.SEQNO              = #{SEQNO, jdbcType=VARCHAR}
    </delete>

    <!-- 판매설정 - 판매변수 저장(동기화 수정) : 판매변수의 상세 속성이 변경되어있으면 반영(화면단에서 변경한 변수는 자동 처리됨) -->
    <update id="updateSaleVarSync" parameterType="map">
MERGE /* com.hitejinro.snop.work.dao.M02020DaoMapper.updateSaleVarSync */
 INTO SCMU.W_SOP_TB_DALY_SCM_SIMUL_SALE_SET_M T
USING (
            SELECT SA.VER_CD, SB.LIQUOR_CODE, SA.SALE_SET_TYPE_CODE, SA.SEQNO
                 , SA.VAL
                 , SB.SALE_VAR_NAME, SB.SALE_VAR_TYPE, SB.USAGE_CODE AS SALE_VAR_USAGE_CODE, SB.ITEM_CODE AS SALE_VAR_ITEM_CODE, SB.VAR_VAL AS SALE_VAR_VAL
              FROM W_SOP_TB_DALY_SCM_SIMUL_SALE_SET_M SA
         LEFT JOIN SCMU.W_SOP_TB_SALE_VAR_DFNT_F      SB
                ON TO_CHAR(SB.SALE_VAR_DFNT_SEQNO) = SA.VAL
             WHERE 1 = 1
               AND SA.VER_CD             = #{verCd, jdbcType=VARCHAR}
               AND SA.SALE_SET_TYPE_CODE = 'SALE_VAR' -- "판매변수"(SALE_VAR) 로 고정
               AND (    -- 상세 속성이 다른 경우
                        NVL(SA.SALE_VAR_TYPE, '^') != SB.SALE_VAR_TYPE
                        OR
                        NVL(SA.SALE_VAR_NAME, '^') != SB.SALE_VAR_NAME
                        OR
                        NVL(SA.LIQUOR_CODE, '^') != SB.LIQUOR_CODE
                        OR
                        NVL(SA.SALE_VAR_USAGE_CODE, '^') != SB.USAGE_CODE
                        OR
                        NVL(SA.SALE_VAR_ITEM_CODE, '^') != SB.ITEM_CODE
                        OR
                        NVL(SA.SALE_VAR_VAL, 0) != SB.VAR_VAL
                   )
      ) S
   ON (T.VER_CD = S.VER_CD AND T.SALE_SET_TYPE_CODE = S.SALE_SET_TYPE_CODE AND T.VAL = S.VAL)
 WHEN MATCHED THEN
    UPDATE
       SET T.LIQUOR_CODE            = S.LIQUOR_CODE
         , T.SALE_VAR_NAME          = S.SALE_VAR_NAME
         , T.SALE_VAR_TYPE          = S.SALE_VAR_TYPE
         , T.SALE_VAR_USAGE_CODE    = S.SALE_VAR_USAGE_CODE
         , T.SALE_VAR_ITEM_CODE     = S.SALE_VAR_ITEM_CODE
         , T.SALE_VAR_VAL           = S.SALE_VAR_VAL
         , T.RMKS                   = '변수 동기화 수정. 이전 값 : SALE_VAR_NAME=' || T.SALE_VAR_NAME || ', SALE_VAR_NAME=' || T.SALE_VAR_NAME || ', LIQUOR_CODE=' || T.LIQUOR_CODE
                                        || ', SALE_VAR_USAGE_CODE=' || T.SALE_VAR_USAGE_CODE || ', SALE_VAR_ITEM_CODE=' || T.SALE_VAR_ITEM_CODE || ', SALE_VAR_VAL=' || T.SALE_VAR_VAL
         , T.LAST_UPDATED_BY        = #{userId, jdbcType=VARCHAR}
         , T.LAST_UPDATE_DATE       = SYSDATE
    </update>
    
    <!-- 판매설정 - 판매변수 저장(동기화 삭제) : 존재하지 않는 변수 삭제 -->
    <delete id="deleteSaleVarSync" parameterType="map">
DELETE /* com.hitejinro.snop.work.dao.M02020DaoMapper.deleteSaleVarSync */
  FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_SALE_SET_M T
 WHERE 1 = 1
   AND T.VER_CD             = #{verCd, jdbcType=VARCHAR}
   AND T.SALE_SET_TYPE_CODE = 'SALE_VAR' -- "판매변수"(SALE_VAR) 로 고정
   AND NOT EXISTS (
                    SELECT 1
                      FROM SCMU.W_SOP_TB_SALE_VAR_DFNT_F X
                     WHERE 1 = 1
                       AND TO_CHAR(X.SALE_VAR_DFNT_SEQNO) = T.VAL
       )
    </delete>


    <!-- 판매설정 - 요일별판매비율 조회 -->
    <select id="searchDowSaleRate" parameterType="map" resultType="map">
    SELECT /* com.hitejinro.snop.work.dao.M02020DaoMapper.searchDowSaleRate */
           A.VER_CD, B.LIQUOR_CODE, B.LIQUOR_DESC
         , C.CODE AS SALE_SET_TYPE_CODE
         --, C.NAME AS SALE_SET_TYPE_NAME
         , SUM(NVL(TO_NUMBER(D.VAL), 0))                                                AS DOW_TOTAL_VAL -- 요일별판매비율의 합산
         -- 요일별판매비율 : 소수점 3째자리로 고정.
         , SUM(CASE WHEN D.DOW_CODE = 'MON' THEN NVL(TO_NUMBER(D.VAL), 0) ELSE 0 END)   AS DOW_MON_VAL
         , SUM(CASE WHEN D.DOW_CODE = 'TUE' THEN NVL(TO_NUMBER(D.VAL), 0) ELSE 0 END)   AS DOW_TUE_VAL
         , SUM(CASE WHEN D.DOW_CODE = 'WED' THEN NVL(TO_NUMBER(D.VAL), 0) ELSE 0 END)   AS DOW_WED_VAL
         , SUM(CASE WHEN D.DOW_CODE = 'THU' THEN NVL(TO_NUMBER(D.VAL), 0) ELSE 0 END)   AS DOW_THU_VAL
         , SUM(CASE WHEN D.DOW_CODE = 'FRI' THEN NVL(TO_NUMBER(D.VAL), 0) ELSE 0 END)   AS DOW_FRI_VAL
      FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_M           A
      JOIN EDW.W_CM_TB_LIQUOR_M                     B
        ON B.LIQUOR_CODE IN ('10', '20') -- 맥주(10), 소주(20)만 대상
      JOIN SCMU.W_SOP_TB_COM_CODE_M                 C
        ON C.GROUP_CODE = 'SALE_SET_TYPE'
       AND C.CODE       = 'DOW_SALE_RATE' -- "요일별판매비율"(DOW_SALE_RATE) 로 고정
 LEFT JOIN SCMU.W_SOP_TB_DALY_SCM_SIMUL_SALE_SET_M  D
        ON D.VER_CD             = A.VER_CD
       AND D.LIQUOR_CODE        = B.LIQUOR_CODE
       AND D.SALE_SET_TYPE_CODE = C.CODE
     WHERE 1 = 1
       AND A.VER_CD = #{verCd, jdbcType=VARCHAR}
     GROUP BY A.VER_CD, B.LIQUOR_CODE, B.LIQUOR_DESC, C.CODE
     ORDER BY A.VER_CD, B.LIQUOR_CODE
    </select>

    <!-- 판매설정 - 요일별판매비율 저장(추가/수정) : 사업부문별로 요일이 고정이라, 삭제는 없음 -->
    <update id="updateDowSaleRate" parameterType="map">
MERGE /* com.hitejinro.snop.work.dao.M02020DaoMapper.updateDowSaleRate */
 INTO SCMU.W_SOP_TB_DALY_SCM_SIMUL_SALE_SET_M T
USING (
            SELECT SA.VER_CD, SA.LIQUOR_CODE, SA.SALE_SET_TYPE_CODE, SB.SEQNO
                 , CASE WHEN SB.DOW_CODE = 'MON' THEN SA.DOW_MON_VAL
                        WHEN SB.DOW_CODE = 'TUE' THEN SA.DOW_TUE_VAL
                        WHEN SB.DOW_CODE = 'WED' THEN SA.DOW_WED_VAL
                        WHEN SB.DOW_CODE = 'THU' THEN SA.DOW_THU_VAL
                        WHEN SB.DOW_CODE = 'FRI' THEN SA.DOW_FRI_VAL
                   END  AS VAL
                 , SB.DOW_CODE
                 , NULL AS ATTRIBUTE1, NULL AS ATTRIBUTE2, NULL AS ATTRIBUTE3, NULL AS ATTRIBUTE4, NULL AS ATTRIBUTE5
              FROM (
        <foreach collection="updateList" item="list" separator="UNION ALL" index="i">
SELECT #{list.VER_CD, jdbcType=VARCHAR}                                                                     AS VER_CD
     , #{list.LIQUOR_CODE, jdbcType=VARCHAR}                                                                AS LIQUOR_CODE
     , 'DOW_SALE_RATE'                                                                                      AS SALE_SET_TYPE_CODE   -- "요일별판매비율"(DOW_SALE_RATE) 로 고정
     , NVL(TO_NUMBER(#{list.DOW_MON_VAL, jdbcType=VARCHAR}), 0)                                             AS DOW_MON_VAL
     , NVL(TO_NUMBER(#{list.DOW_TUE_VAL, jdbcType=VARCHAR}), 0)                                             AS DOW_TUE_VAL
     , NVL(TO_NUMBER(#{list.DOW_WED_VAL, jdbcType=VARCHAR}), 0)                                             AS DOW_WED_VAL
     , NVL(TO_NUMBER(#{list.DOW_THU_VAL, jdbcType=VARCHAR}), 0)                                             AS DOW_THU_VAL
     , NVL(TO_NUMBER(#{list.DOW_FRI_VAL, jdbcType=VARCHAR}), 0)                                             AS DOW_FRI_VAL
     
     , #{list.action, jdbcType=VARCHAR}                                                                     AS ROW_ACTION   -- 행 상태 : insert, update, delete
     , ROWNUM                                                                                               AS RNUM
  FROM DUAL
        </foreach>
                   ) SA
        CROSS JOIN (    -- SB. 요일 컬럼을 행으로 변환 : 요일별로 SEQNO는 고정(WEEK_OF_DAY : 토=1, 일=7)
                        SELECT 2 AS SEQNO, 'MON' AS DOW_CODE FROM DUAL UNION ALL
                        SELECT 3 AS SEQNO, 'TUE' AS DOW_CODE FROM DUAL UNION ALL
                        SELECT 4 AS SEQNO, 'WED' AS DOW_CODE FROM DUAL UNION ALL
                        SELECT 5 AS SEQNO, 'THU' AS DOW_CODE FROM DUAL UNION ALL
                        SELECT 6 AS SEQNO, 'FRI' AS DOW_CODE FROM DUAL
                   ) SB
             WHERE 1 = 1
      ) S
   ON (T.VER_CD = S.VER_CD AND T.LIQUOR_CODE = S.LIQUOR_CODE AND T.SALE_SET_TYPE_CODE = S.SALE_SET_TYPE_CODE AND T.SEQNO = S.SEQNO)
 WHEN MATCHED THEN
    UPDATE
       SET T.VAL                    = TRIM(TO_CHAR(ROUND(S.VAL, 3), '990.999')) -- 비율은 소수점 셋째자리까지만 사용하고, 문자열로 저장
         , T.DOW_CODE               = S.DOW_CODE -- 바뀔일은 없지만, 같이 처리
         -- 열이 행으로 바뀌는 것이라서, 변화없으면 변경정보는 유지
         , T.LAST_UPDATED_BY        = CASE WHEN T.VAL = TRIM(TO_CHAR(ROUND(S.VAL, 3), '990.999')) THEN T.LAST_UPDATED_BY
                                           ELSE                                                        #{userId, jdbcType=VARCHAR}
                                      END
         , T.LAST_UPDATE_DATE       = CASE WHEN T.VAL = TRIM(TO_CHAR(ROUND(S.VAL, 3), '990.999')) THEN T.LAST_UPDATE_DATE
                                           ELSE                                                        SYSDATE
                                      END
 
 WHEN NOT MATCHED THEN
    INSERT (T.VER_CD, T.LIQUOR_CODE, T.SALE_SET_TYPE_CODE, T.SEQNO
            , T.VAL
            , T.DOW_CODE
            , T.USE_SALE_QTY_YYYYMM, T.SALE_VAR_APL_FR_DT, T.SALE_VAR_APL_TO_DT, T.SALE_VAR_NAME, T.SALE_VAR_TYPE, T.SALE_VAR_USAGE_CODE, T.SALE_VAR_ITEM_CODE, T.SALE_VAR_VAL
            , T.RMKS, T.ATTRIBUTE1, T.ATTRIBUTE2, T.ATTRIBUTE3, T.ATTRIBUTE4, T.ATTRIBUTE5, T.CREATED_BY, T.CREATION_DATE, T.LAST_UPDATED_BY, T.LAST_UPDATE_DATE)
    VALUES (S.VER_CD, S.LIQUOR_CODE, S.SALE_SET_TYPE_CODE, S.SEQNO
            , TRIM(TO_CHAR(ROUND(S.VAL, 3), '990.999'))
            , S.DOW_CODE
            , NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL
            , NULL, S.ATTRIBUTE1, S.ATTRIBUTE2, S.ATTRIBUTE3, S.ATTRIBUTE4, S.ATTRIBUTE5, #{userId, jdbcType=VARCHAR}, SYSDATE, #{userId, jdbcType=VARCHAR}, SYSDATE)
    </update>


    <!-- 판매설정 - 판매량 계산(생성=추가) : 설정된 사용판매량/실적반영방법/판매변수/요일별판매비율을 이용하여, 일자별 판매량 산출 -->
    <update id="updateSale" parameterType="map">
        <![CDATA[
INSERT /* com.hitejinro.snop.work.dao.M02020DaoMapper.updateSale */
  INTO SCMU.W_SOP_TB_DALY_SCM_SIMUL_SALE_F
       (VER_CD, ITEM_MAP_YN, LIQUOR_CODE, PERIOD_YYYYMMDD, ITEM_CODE
        , SALE_QTY, BF_SALE_VAR_APL_SALE_QTY, AF_SALE_VAR_APL_SALE_QTY, MODIFY_YN, SALE_TYPE, SALE_VAR_DFNT_SEQNO, SALE_VAR_VAL, RMKS
        , ATTRIBUTE1, ATTRIBUTE2, ATTRIBUTE3, ATTRIBUTE4, ATTRIBUTE5
        , CREATED_BY, CREATION_DATE, LAST_UPDATED_BY, LAST_UPDATE_DATE)
    SELECT A.VER_CD
         , K.ITEM_MAP_YN -- 제품 매핑 여부
         , C.LIQUOR_CODE
         , B.YYYYMMDD   AS PERIOD_YYYYMMDD
         , CASE WHEN K.ITEM_MAP_YN = 'N'        THEN F.ITEM_CODE
                WHEN J.FR_ITEM_CODE IS NOT NULL THEN J.TO_ITEM_CODE
                ELSE                                 F.ITEM_CODE
           END          AS ITEM_CODE
         , SUM(
                   CASE WHEN B.YYYYMMDD <= A.STD_YYYYMMDD                         THEN NVL(F.ACTUAL_SALE_QTY, 0)
                        WHEN B.YYYYMMDD >  A.STD_YYYYMMDD AND C.VAL = 'ESPN_SALE' THEN CASE WHEN NVL(G.VER_PLAN_WORK_CNT, 0) = 0 OR NVL(G.SCM_YYYYWW_WORK_CNT, 0) = 0   THEN NVL(F.ESPN_SALE_QTY / DECODE(F.UOM_CONVERSION_VALUE, 0, NULL, F.UOM_CONVERSION_VALUE), 0)  -- 주차의 영업일수가 0이면 그대로 사용. 영업예상량은 환산c/s로 들어있어서, 역산 처리
                                                                                            WHEN G.SC_YYYYWW_STD_WW_YN = 'Y' AND D.ACTUAL_RFLT_TYPE = 'DIST_EQUAL'      THEN NVL(H.SCM_YYYYWW_ESPN_SALE_QTY, 0) * (G.VER_PLAN_WORK_CNT / G.SCM_YYYYWW_WORK_CNT)         -- 실적주차 : 균등이므로, 주차기준의 수량 합계를 남은 영업일수 비율만큼
                                                                                            WHEN G.SC_YYYYWW_STD_WW_YN = 'Y' AND D.ACTUAL_RFLT_TYPE = 'DIST_DIFF'       THEN NVL(H.SCM_YYYYWW_ESPN_SALE_QTY, 0) - NVL(H.VER_SCM_YYYYWW_ACTUAL_SALE_QTY, 0)              -- 실적주차 : 차액배분이므로, 주차기준의 계획 수량 합계에서 실적 수량 합계를 차감
                                                                                            WHEN G.SC_YYYYWW_STD_WW_YN = 'N'                                            THEN NVL(H.SCM_YYYYWW_ESPN_SALE_QTY, 0)                                                         -- 실적주차가 아니므로, 주차기준의 계획 수량 합계
                                                                                            ELSE 0
                                                                                       END      -- za. 영업일수가 0이면, 그냥 영업마트의 수량 그대로 사용. 아니면, 영업마트에서 남은 계획일수(영업일)만큼에 해당하는 금액 합산 추출
                                                                                       * CASE WHEN NVL(G.VER_PLAN_WORK_CNT, 0) = 0 OR NVL(G.SCM_YYYYWW_WORK_CNT, 0) = 0       THEN 1
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '2' THEN NVL(E.DOW_MON_RATE, 0)
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '3' THEN NVL(E.DOW_TUE_RATE, 0)
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '4' THEN NVL(E.DOW_WED_RATE, 0)
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '5' THEN NVL(E.DOW_THU_RATE, 0)
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '6' THEN NVL(E.DOW_FRI_RATE, 0)
                                                                                              ELSE 0
                                                                                         END    -- zb. 영업일수가 0이면, 1. 아니면, 해당 일자의 요일별판매비율
                                                                                       / CASE WHEN NVL(G.VER_PLAN_WORK_CNT, 0) = 0 OR NVL(G.SCM_YYYYWW_WORK_CNT, 0) = 0 THEN 1
                                                                                              WHEN (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '월') > 0 THEN NVL(E.DOW_MON_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '화') > 0 THEN NVL(E.DOW_TUE_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '수') > 0 THEN NVL(E.DOW_WED_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '목') > 0 THEN NVL(E.DOW_THU_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '금') > 0 THEN NVL(E.DOW_FRI_RATE, 0) ELSE 0 END) = 0 THEN G.VER_PLAN_WORK_CNT
                                                                                              ELSE (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '월') > 0 THEN NVL(E.DOW_MON_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '화') > 0 THEN NVL(E.DOW_TUE_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '수') > 0 THEN NVL(E.DOW_WED_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '목') > 0 THEN NVL(E.DOW_THU_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '금') > 0 THEN NVL(E.DOW_FRI_RATE, 0) ELSE 0 END)
                                                                                         END    -- zc. 영업일수가 0이면, 1. 아니면, 남은 계획일수(영업일)에 해당하는 요일별판매비율 합산
                        WHEN B.YYYYMMDD >  A.STD_YYYYMMDD AND C.VAL = 'SALE_PLAN' THEN CASE WHEN NVL(G.VER_PLAN_WORK_CNT, 0) = 0 OR NVL(G.SCM_YYYYWW_WORK_CNT, 0) = 0   THEN NVL(F.MM_SALE_PLAN_QTY, 0)                                                            -- 주차의 영업일수가 0이면 그대로 사용.
                                                                                            WHEN G.SC_YYYYWW_STD_WW_YN = 'Y' AND D.ACTUAL_RFLT_TYPE = 'DIST_EQUAL'      THEN NVL(H.SCM_YYYYWW_MM_SALE_PLAN_QTY, 0) * (G.VER_PLAN_WORK_CNT / G.SCM_YYYYWW_WORK_CNT) -- 실적주차 : 균등이므로, 주차기준의 수량 합계를 남은 영업일수 비율만큼
                                                                                            WHEN G.SC_YYYYWW_STD_WW_YN = 'Y' AND D.ACTUAL_RFLT_TYPE = 'DIST_DIFF'       THEN NVL(H.SCM_YYYYWW_MM_SALE_PLAN_QTY, 0) - NVL(H.VER_SCM_YYYYWW_ACTUAL_SALE_QTY, 0)      -- 실적주차 : 차액배분이므로, 주차기준의 계획 수량 합계에서 실적 수량 합계를 차감
                                                                                            WHEN G.SC_YYYYWW_STD_WW_YN = 'N'                                            THEN NVL(H.SCM_YYYYWW_MM_SALE_PLAN_QTY, 0)                                                 -- 실적주차가 아니므로, 주차기준의 계획 수량 합계
                                                                                            ELSE 0
                                                                                       END      -- za. 영업일수가 0이면, 그냥 영업마트의 수량 그대로 사용. 아니면, 영업마트에서 남은 계획일수(영업일)만큼에 해당하는 금액 합산 추출
                                                                                       * CASE WHEN NVL(G.VER_PLAN_WORK_CNT, 0) = 0 OR NVL(G.SCM_YYYYWW_WORK_CNT, 0) = 0       THEN 1
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '2' THEN NVL(E.DOW_MON_RATE, 0)
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '3' THEN NVL(E.DOW_TUE_RATE, 0)
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '4' THEN NVL(E.DOW_WED_RATE, 0)
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '5' THEN NVL(E.DOW_THU_RATE, 0)
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '6' THEN NVL(E.DOW_FRI_RATE, 0)
                                                                                              ELSE 0
                                                                                         END    -- zb. 영업일수가 0이면, 1. 아니면, 해당 일자의 요일별판매비율
                                                                                       / CASE WHEN NVL(G.VER_PLAN_WORK_CNT, 0) = 0 OR NVL(G.SCM_YYYYWW_WORK_CNT, 0) = 0 THEN 1
                                                                                              WHEN (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '월') > 0 THEN NVL(E.DOW_MON_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '화') > 0 THEN NVL(E.DOW_TUE_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '수') > 0 THEN NVL(E.DOW_WED_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '목') > 0 THEN NVL(E.DOW_THU_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '금') > 0 THEN NVL(E.DOW_FRI_RATE, 0) ELSE 0 END) = 0 THEN G.VER_PLAN_WORK_CNT
                                                                                              ELSE (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '월') > 0 THEN NVL(E.DOW_MON_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '화') > 0 THEN NVL(E.DOW_TUE_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '수') > 0 THEN NVL(E.DOW_WED_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '목') > 0 THEN NVL(E.DOW_THU_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '금') > 0 THEN NVL(E.DOW_FRI_RATE, 0) ELSE 0 END)
                                                                                         END    -- zc. 영업일수가 0이면, 1. 아니면, 남은 계획일수(영업일)에 해당하는 요일별판매비율 합산
                        WHEN B.YYYYMMDD >  A.STD_YYYYMMDD AND C.VAL = 'YYYY_TRG'  THEN CASE WHEN NVL(G.VER_PLAN_WORK_CNT, 0) = 0 OR NVL(G.SCM_YYYYWW_WORK_CNT, 0) = 0   THEN NVL(F.YYYY_TRG_SALE_CONV_QTY / DECODE(F.UOM_CONVERSION_VALUE, 0, NULL, F.UOM_CONVERSION_VALUE), 0) -- 주차의 영업일수가 0이면 그대로 사용.
                                                                                            WHEN G.SC_YYYYWW_STD_WW_YN = 'Y' AND D.ACTUAL_RFLT_TYPE = 'DIST_EQUAL'      THEN NVL(H.SCM_YYYYWW_YYYY_TRG_SALE_QTY, 0) * (G.VER_PLAN_WORK_CNT / G.SCM_YYYYWW_WORK_CNT) -- 실적주차 : 균등이므로, 주차기준의 수량 합계를 남은 영업일수 비율만큼
                                                                                            WHEN G.SC_YYYYWW_STD_WW_YN = 'Y' AND D.ACTUAL_RFLT_TYPE = 'DIST_DIFF'       THEN NVL(H.SCM_YYYYWW_YYYY_TRG_SALE_QTY, 0) - NVL(H.VER_SCM_YYYYWW_ACTUAL_SALE_QTY, 0)      -- 실적주차 : 차액배분이므로, 주차기준의 계획 수량 합계에서 실적 수량 합계를 차감
                                                                                            WHEN G.SC_YYYYWW_STD_WW_YN = 'N'                                            THEN NVL(H.SCM_YYYYWW_YYYY_TRG_SALE_QTY, 0)                                                 -- 실적주차가 아니므로, 주차기준의 계획 수량 합계
                                                                                            ELSE 0
                                                                                       END      -- za. 영업일수가 0이면, 그냥 영업마트의 수량 그대로 사용. 아니면, 영업마트에서 남은 계획일수(영업일)만큼에 해당하는 금액 합산 추출
                                                                                       * CASE WHEN NVL(G.VER_PLAN_WORK_CNT, 0) = 0 OR NVL(G.SCM_YYYYWW_WORK_CNT, 0) = 0       THEN 1
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '2' THEN NVL(E.DOW_MON_RATE, 0)
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '3' THEN NVL(E.DOW_TUE_RATE, 0)
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '4' THEN NVL(E.DOW_WED_RATE, 0)
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '5' THEN NVL(E.DOW_THU_RATE, 0)
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '6' THEN NVL(E.DOW_FRI_RATE, 0)
                                                                                              ELSE 0
                                                                                         END    -- zb. 영업일수가 0이면, 1. 아니면, 해당 일자의 요일별판매비율
                                                                                       / CASE WHEN NVL(G.VER_PLAN_WORK_CNT, 0) = 0 OR NVL(G.SCM_YYYYWW_WORK_CNT, 0) = 0 THEN 1
                                                                                              WHEN (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '월') > 0 THEN NVL(E.DOW_MON_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '화') > 0 THEN NVL(E.DOW_TUE_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '수') > 0 THEN NVL(E.DOW_WED_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '목') > 0 THEN NVL(E.DOW_THU_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '금') > 0 THEN NVL(E.DOW_FRI_RATE, 0) ELSE 0 END) = 0 THEN G.VER_PLAN_WORK_CNT
                                                                                              ELSE (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '월') > 0 THEN NVL(E.DOW_MON_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '화') > 0 THEN NVL(E.DOW_TUE_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '수') > 0 THEN NVL(E.DOW_WED_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '목') > 0 THEN NVL(E.DOW_THU_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '금') > 0 THEN NVL(E.DOW_FRI_RATE, 0) ELSE 0 END)
                                                                                         END    -- zc. 영업일수가 0이면, 1. 아니면, 남은 계획일수(영업일)에 해당하는 요일별판매비율 합산
                        ELSE 0
                   END
                   * CASE WHEN K.ITEM_MAP_YN = 'N'        THEN 1
                          WHEN J.FR_ITEM_CODE IS NOT NULL THEN J.CONVERSION_VALUE
                          ELSE                                 1
                     END -- 제품 매핑시에는 해당 To제품으로 환산
              )         AS SALE_QTY     -- 판매량(단순c/s)
         , SUM(
                   CASE WHEN B.YYYYMMDD <= A.STD_YYYYMMDD                         THEN NVL(F.ACTUAL_SALE_QTY, 0)
                        WHEN B.YYYYMMDD >  A.STD_YYYYMMDD AND C.VAL = 'ESPN_SALE' THEN CASE WHEN NVL(G.VER_PLAN_WORK_CNT, 0) = 0 OR NVL(G.SCM_YYYYWW_WORK_CNT, 0) = 0   THEN NVL(F.ESPN_SALE_QTY / DECODE(F.UOM_CONVERSION_VALUE, 0, NULL, F.UOM_CONVERSION_VALUE), 0)  -- 주차의 영업일수가 0이면 그대로 사용. 영업예상량은 환산c/s로 들어있어서, 역산 처리
                                                                                            WHEN G.SC_YYYYWW_STD_WW_YN = 'Y' AND D.ACTUAL_RFLT_TYPE = 'DIST_EQUAL'      THEN NVL(H.SCM_YYYYWW_ESPN_SALE_QTY, 0) * (G.VER_PLAN_WORK_CNT / G.SCM_YYYYWW_WORK_CNT)         -- 실적주차 : 균등이므로, 주차기준의 수량 합계를 남은 영업일수 비율만큼
                                                                                            WHEN G.SC_YYYYWW_STD_WW_YN = 'Y' AND D.ACTUAL_RFLT_TYPE = 'DIST_DIFF'       THEN NVL(H.SCM_YYYYWW_ESPN_SALE_QTY, 0) - NVL(H.VER_SCM_YYYYWW_ACTUAL_SALE_QTY, 0)              -- 실적주차 : 차액배분이므로, 주차기준의 계획 수량 합계에서 실적 수량 합계를 차감
                                                                                            WHEN G.SC_YYYYWW_STD_WW_YN = 'N'                                            THEN NVL(H.SCM_YYYYWW_ESPN_SALE_QTY, 0)                                                         -- 실적주차가 아니므로, 주차기준의 계획 수량 합계
                                                                                            ELSE 0
                                                                                       END      -- za. 영업일수가 0이면, 그냥 영업마트의 수량 그대로 사용. 아니면, 영업마트에서 남은 계획일수(영업일)만큼에 해당하는 금액 합산 추출
                                                                                       * CASE WHEN NVL(G.VER_PLAN_WORK_CNT, 0) = 0 OR NVL(G.SCM_YYYYWW_WORK_CNT, 0) = 0       THEN 1
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '2' THEN NVL(E.DOW_MON_RATE, 0)
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '3' THEN NVL(E.DOW_TUE_RATE, 0)
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '4' THEN NVL(E.DOW_WED_RATE, 0)
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '5' THEN NVL(E.DOW_THU_RATE, 0)
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '6' THEN NVL(E.DOW_FRI_RATE, 0)
                                                                                              ELSE 0
                                                                                         END    -- zb. 영업일수가 0이면, 1. 아니면, 해당 일자의 요일별판매비율
                                                                                       / CASE WHEN NVL(G.VER_PLAN_WORK_CNT, 0) = 0 OR NVL(G.SCM_YYYYWW_WORK_CNT, 0) = 0 THEN 1
                                                                                              WHEN (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '월') > 0 THEN NVL(E.DOW_MON_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '화') > 0 THEN NVL(E.DOW_TUE_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '수') > 0 THEN NVL(E.DOW_WED_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '목') > 0 THEN NVL(E.DOW_THU_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '금') > 0 THEN NVL(E.DOW_FRI_RATE, 0) ELSE 0 END) = 0 THEN G.VER_PLAN_WORK_CNT
                                                                                              ELSE (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '월') > 0 THEN NVL(E.DOW_MON_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '화') > 0 THEN NVL(E.DOW_TUE_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '수') > 0 THEN NVL(E.DOW_WED_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '목') > 0 THEN NVL(E.DOW_THU_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '금') > 0 THEN NVL(E.DOW_FRI_RATE, 0) ELSE 0 END)
                                                                                         END    -- zc. 영업일수가 0이면, 1. 아니면, 남은 계획일수(영업일)에 해당하는 요일별판매비율 합산
                        WHEN B.YYYYMMDD >  A.STD_YYYYMMDD AND C.VAL = 'SALE_PLAN' THEN CASE WHEN NVL(G.VER_PLAN_WORK_CNT, 0) = 0 OR NVL(G.SCM_YYYYWW_WORK_CNT, 0) = 0   THEN NVL(F.MM_SALE_PLAN_QTY, 0)                                                            -- 주차의 영업일수가 0이면 그대로 사용.
                                                                                            WHEN G.SC_YYYYWW_STD_WW_YN = 'Y' AND D.ACTUAL_RFLT_TYPE = 'DIST_EQUAL'      THEN NVL(H.SCM_YYYYWW_MM_SALE_PLAN_QTY, 0) * (G.VER_PLAN_WORK_CNT / G.SCM_YYYYWW_WORK_CNT) -- 실적주차 : 균등이므로, 주차기준의 수량 합계를 남은 영업일수 비율만큼
                                                                                            WHEN G.SC_YYYYWW_STD_WW_YN = 'Y' AND D.ACTUAL_RFLT_TYPE = 'DIST_DIFF'       THEN NVL(H.SCM_YYYYWW_MM_SALE_PLAN_QTY, 0) - NVL(H.VER_SCM_YYYYWW_ACTUAL_SALE_QTY, 0)      -- 실적주차 : 차액배분이므로, 주차기준의 계획 수량 합계에서 실적 수량 합계를 차감
                                                                                            WHEN G.SC_YYYYWW_STD_WW_YN = 'N'                                            THEN NVL(H.SCM_YYYYWW_MM_SALE_PLAN_QTY, 0)                                                 -- 실적주차가 아니므로, 주차기준의 계획 수량 합계
                                                                                            ELSE 0
                                                                                       END      -- za. 영업일수가 0이면, 그냥 영업마트의 수량 그대로 사용. 아니면, 영업마트에서 남은 계획일수(영업일)만큼에 해당하는 금액 합산 추출
                                                                                       * CASE WHEN NVL(G.VER_PLAN_WORK_CNT, 0) = 0 OR NVL(G.SCM_YYYYWW_WORK_CNT, 0) = 0       THEN 1
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '2' THEN NVL(E.DOW_MON_RATE, 0)
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '3' THEN NVL(E.DOW_TUE_RATE, 0)
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '4' THEN NVL(E.DOW_WED_RATE, 0)
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '5' THEN NVL(E.DOW_THU_RATE, 0)
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '6' THEN NVL(E.DOW_FRI_RATE, 0)
                                                                                              ELSE 0
                                                                                         END    -- zb. 영업일수가 0이면, 1. 아니면, 해당 일자의 요일별판매비율
                                                                                       / CASE WHEN NVL(G.VER_PLAN_WORK_CNT, 0) = 0 OR NVL(G.SCM_YYYYWW_WORK_CNT, 0) = 0 THEN 1
                                                                                              WHEN (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '월') > 0 THEN NVL(E.DOW_MON_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '화') > 0 THEN NVL(E.DOW_TUE_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '수') > 0 THEN NVL(E.DOW_WED_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '목') > 0 THEN NVL(E.DOW_THU_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '금') > 0 THEN NVL(E.DOW_FRI_RATE, 0) ELSE 0 END) = 0 THEN G.VER_PLAN_WORK_CNT
                                                                                              ELSE (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '월') > 0 THEN NVL(E.DOW_MON_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '화') > 0 THEN NVL(E.DOW_TUE_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '수') > 0 THEN NVL(E.DOW_WED_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '목') > 0 THEN NVL(E.DOW_THU_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '금') > 0 THEN NVL(E.DOW_FRI_RATE, 0) ELSE 0 END)
                                                                                         END    -- zc. 영업일수가 0이면, 1. 아니면, 남은 계획일수(영업일)에 해당하는 요일별판매비율 합산
                        WHEN B.YYYYMMDD >  A.STD_YYYYMMDD AND C.VAL = 'YYYY_TRG'  THEN CASE WHEN NVL(G.VER_PLAN_WORK_CNT, 0) = 0 OR NVL(G.SCM_YYYYWW_WORK_CNT, 0) = 0   THEN NVL(F.YYYY_TRG_SALE_CONV_QTY / DECODE(F.UOM_CONVERSION_VALUE, 0, NULL, F.UOM_CONVERSION_VALUE), 0) -- 주차의 영업일수가 0이면 그대로 사용.
                                                                                            WHEN G.SC_YYYYWW_STD_WW_YN = 'Y' AND D.ACTUAL_RFLT_TYPE = 'DIST_EQUAL'      THEN NVL(H.SCM_YYYYWW_YYYY_TRG_SALE_QTY, 0) * (G.VER_PLAN_WORK_CNT / G.SCM_YYYYWW_WORK_CNT) -- 실적주차 : 균등이므로, 주차기준의 수량 합계를 남은 영업일수 비율만큼
                                                                                            WHEN G.SC_YYYYWW_STD_WW_YN = 'Y' AND D.ACTUAL_RFLT_TYPE = 'DIST_DIFF'       THEN NVL(H.SCM_YYYYWW_YYYY_TRG_SALE_QTY, 0) - NVL(H.VER_SCM_YYYYWW_ACTUAL_SALE_QTY, 0)      -- 실적주차 : 차액배분이므로, 주차기준의 계획 수량 합계에서 실적 수량 합계를 차감
                                                                                            WHEN G.SC_YYYYWW_STD_WW_YN = 'N'                                            THEN NVL(H.SCM_YYYYWW_YYYY_TRG_SALE_QTY, 0)                                                 -- 실적주차가 아니므로, 주차기준의 계획 수량 합계
                                                                                            ELSE 0
                                                                                       END      -- za. 영업일수가 0이면, 그냥 영업마트의 수량 그대로 사용. 아니면, 영업마트에서 남은 계획일수(영업일)만큼에 해당하는 금액 합산 추출
                                                                                       * CASE WHEN NVL(G.VER_PLAN_WORK_CNT, 0) = 0 OR NVL(G.SCM_YYYYWW_WORK_CNT, 0) = 0       THEN 1
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '2' THEN NVL(E.DOW_MON_RATE, 0)
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '3' THEN NVL(E.DOW_TUE_RATE, 0)
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '4' THEN NVL(E.DOW_WED_RATE, 0)
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '5' THEN NVL(E.DOW_THU_RATE, 0)
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '6' THEN NVL(E.DOW_FRI_RATE, 0)
                                                                                              ELSE 0
                                                                                         END    -- zb. 영업일수가 0이면, 1. 아니면, 해당 일자의 요일별판매비율
                                                                                       / CASE WHEN NVL(G.VER_PLAN_WORK_CNT, 0) = 0 OR NVL(G.SCM_YYYYWW_WORK_CNT, 0) = 0 THEN 1
                                                                                              WHEN (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '월') > 0 THEN NVL(E.DOW_MON_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '화') > 0 THEN NVL(E.DOW_TUE_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '수') > 0 THEN NVL(E.DOW_WED_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '목') > 0 THEN NVL(E.DOW_THU_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '금') > 0 THEN NVL(E.DOW_FRI_RATE, 0) ELSE 0 END) = 0 THEN G.VER_PLAN_WORK_CNT
                                                                                              ELSE (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '월') > 0 THEN NVL(E.DOW_MON_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '화') > 0 THEN NVL(E.DOW_TUE_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '수') > 0 THEN NVL(E.DOW_WED_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '목') > 0 THEN NVL(E.DOW_THU_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '금') > 0 THEN NVL(E.DOW_FRI_RATE, 0) ELSE 0 END)
                                                                                         END    -- zc. 영업일수가 0이면, 1. 아니면, 남은 계획일수(영업일)에 해당하는 요일별판매비율 합산
                        ELSE 0
                   END
                   * CASE WHEN K.ITEM_MAP_YN = 'N'        THEN 1
                          WHEN J.FR_ITEM_CODE IS NOT NULL THEN J.CONVERSION_VALUE
                          ELSE                                 1
                     END -- 제품 매핑시에는 해당 To제품으로 환산
              )         AS BF_SALE_VAR_APL_SALE_QTY
         , SUM(
                   CASE WHEN B.YYYYMMDD <= A.STD_YYYYMMDD                         THEN NVL(F.ACTUAL_SALE_QTY, 0)
                        WHEN B.YYYYMMDD >  A.STD_YYYYMMDD AND C.VAL = 'ESPN_SALE' THEN CASE WHEN NVL(G.VER_PLAN_WORK_CNT, 0) = 0 OR NVL(G.SCM_YYYYWW_WORK_CNT, 0) = 0   THEN NVL(F.ESPN_SALE_QTY / DECODE(F.UOM_CONVERSION_VALUE, 0, NULL, F.UOM_CONVERSION_VALUE), 0)  -- 주차의 영업일수가 0이면 그대로 사용. 영업예상량은 환산c/s로 들어있어서, 역산 처리
                                                                                            WHEN G.SC_YYYYWW_STD_WW_YN = 'Y' AND D.ACTUAL_RFLT_TYPE = 'DIST_EQUAL'      THEN NVL(H.SCM_YYYYWW_ESPN_SALE_QTY, 0) * (G.VER_PLAN_WORK_CNT / G.SCM_YYYYWW_WORK_CNT)         -- 실적주차 : 균등이므로, 주차기준의 수량 합계를 남은 영업일수 비율만큼
                                                                                            WHEN G.SC_YYYYWW_STD_WW_YN = 'Y' AND D.ACTUAL_RFLT_TYPE = 'DIST_DIFF'       THEN NVL(H.SCM_YYYYWW_ESPN_SALE_QTY, 0) - NVL(H.VER_SCM_YYYYWW_ACTUAL_SALE_QTY, 0)              -- 실적주차 : 차액배분이므로, 주차기준의 계획 수량 합계에서 실적 수량 합계를 차감
                                                                                            WHEN G.SC_YYYYWW_STD_WW_YN = 'N'                                            THEN NVL(H.SCM_YYYYWW_ESPN_SALE_QTY, 0)                                                         -- 실적주차가 아니므로, 주차기준의 계획 수량 합계
                                                                                            ELSE 0
                                                                                       END      -- za. 영업일수가 0이면, 그냥 영업마트의 수량 그대로 사용. 아니면, 영업마트에서 남은 계획일수(영업일)만큼에 해당하는 금액 합산 추출
                                                                                       * CASE WHEN NVL(G.VER_PLAN_WORK_CNT, 0) = 0 OR NVL(G.SCM_YYYYWW_WORK_CNT, 0) = 0       THEN 1
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '2' THEN NVL(E.DOW_MON_RATE, 0)
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '3' THEN NVL(E.DOW_TUE_RATE, 0)
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '4' THEN NVL(E.DOW_WED_RATE, 0)
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '5' THEN NVL(E.DOW_THU_RATE, 0)
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '6' THEN NVL(E.DOW_FRI_RATE, 0)
                                                                                              ELSE 0
                                                                                         END    -- zb. 영업일수가 0이면, 1. 아니면, 해당 일자의 요일별판매비율
                                                                                       / CASE WHEN NVL(G.VER_PLAN_WORK_CNT, 0) = 0 OR NVL(G.SCM_YYYYWW_WORK_CNT, 0) = 0 THEN 1
                                                                                              WHEN (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '월') > 0 THEN NVL(E.DOW_MON_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '화') > 0 THEN NVL(E.DOW_TUE_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '수') > 0 THEN NVL(E.DOW_WED_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '목') > 0 THEN NVL(E.DOW_THU_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '금') > 0 THEN NVL(E.DOW_FRI_RATE, 0) ELSE 0 END) = 0 THEN G.VER_PLAN_WORK_CNT
                                                                                              ELSE (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '월') > 0 THEN NVL(E.DOW_MON_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '화') > 0 THEN NVL(E.DOW_TUE_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '수') > 0 THEN NVL(E.DOW_WED_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '목') > 0 THEN NVL(E.DOW_THU_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '금') > 0 THEN NVL(E.DOW_FRI_RATE, 0) ELSE 0 END)
                                                                                         END    -- zc. 영업일수가 0이면, 1. 아니면, 남은 계획일수(영업일)에 해당하는 요일별판매비율 합산
                        WHEN B.YYYYMMDD >  A.STD_YYYYMMDD AND C.VAL = 'SALE_PLAN' THEN CASE WHEN NVL(G.VER_PLAN_WORK_CNT, 0) = 0 OR NVL(G.SCM_YYYYWW_WORK_CNT, 0) = 0   THEN NVL(F.MM_SALE_PLAN_QTY, 0)                                                            -- 주차의 영업일수가 0이면 그대로 사용.
                                                                                            WHEN G.SC_YYYYWW_STD_WW_YN = 'Y' AND D.ACTUAL_RFLT_TYPE = 'DIST_EQUAL'      THEN NVL(H.SCM_YYYYWW_MM_SALE_PLAN_QTY, 0) * (G.VER_PLAN_WORK_CNT / G.SCM_YYYYWW_WORK_CNT) -- 실적주차 : 균등이므로, 주차기준의 수량 합계를 남은 영업일수 비율만큼
                                                                                            WHEN G.SC_YYYYWW_STD_WW_YN = 'Y' AND D.ACTUAL_RFLT_TYPE = 'DIST_DIFF'       THEN NVL(H.SCM_YYYYWW_MM_SALE_PLAN_QTY, 0) - NVL(H.VER_SCM_YYYYWW_ACTUAL_SALE_QTY, 0)      -- 실적주차 : 차액배분이므로, 주차기준의 계획 수량 합계에서 실적 수량 합계를 차감
                                                                                            WHEN G.SC_YYYYWW_STD_WW_YN = 'N'                                            THEN NVL(H.SCM_YYYYWW_MM_SALE_PLAN_QTY, 0)                                                 -- 실적주차가 아니므로, 주차기준의 계획 수량 합계
                                                                                            ELSE 0
                                                                                       END      -- za. 영업일수가 0이면, 그냥 영업마트의 수량 그대로 사용. 아니면, 영업마트에서 남은 계획일수(영업일)만큼에 해당하는 금액 합산 추출
                                                                                       * CASE WHEN NVL(G.VER_PLAN_WORK_CNT, 0) = 0 OR NVL(G.SCM_YYYYWW_WORK_CNT, 0) = 0       THEN 1
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '2' THEN NVL(E.DOW_MON_RATE, 0)
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '3' THEN NVL(E.DOW_TUE_RATE, 0)
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '4' THEN NVL(E.DOW_WED_RATE, 0)
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '5' THEN NVL(E.DOW_THU_RATE, 0)
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '6' THEN NVL(E.DOW_FRI_RATE, 0)
                                                                                              ELSE 0
                                                                                         END    -- zb. 영업일수가 0이면, 1. 아니면, 해당 일자의 요일별판매비율
                                                                                       / CASE WHEN NVL(G.VER_PLAN_WORK_CNT, 0) = 0 OR NVL(G.SCM_YYYYWW_WORK_CNT, 0) = 0 THEN 1
                                                                                              WHEN (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '월') > 0 THEN NVL(E.DOW_MON_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '화') > 0 THEN NVL(E.DOW_TUE_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '수') > 0 THEN NVL(E.DOW_WED_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '목') > 0 THEN NVL(E.DOW_THU_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '금') > 0 THEN NVL(E.DOW_FRI_RATE, 0) ELSE 0 END) = 0 THEN G.VER_PLAN_WORK_CNT
                                                                                              ELSE (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '월') > 0 THEN NVL(E.DOW_MON_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '화') > 0 THEN NVL(E.DOW_TUE_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '수') > 0 THEN NVL(E.DOW_WED_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '목') > 0 THEN NVL(E.DOW_THU_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '금') > 0 THEN NVL(E.DOW_FRI_RATE, 0) ELSE 0 END)
                                                                                         END    -- zc. 영업일수가 0이면, 1. 아니면, 남은 계획일수(영업일)에 해당하는 요일별판매비율 합산
                        WHEN B.YYYYMMDD >  A.STD_YYYYMMDD AND C.VAL = 'YYYY_TRG'  THEN CASE WHEN NVL(G.VER_PLAN_WORK_CNT, 0) = 0 OR NVL(G.SCM_YYYYWW_WORK_CNT, 0) = 0   THEN NVL(F.YYYY_TRG_SALE_CONV_QTY / DECODE(F.UOM_CONVERSION_VALUE, 0, NULL, F.UOM_CONVERSION_VALUE), 0) -- 주차의 영업일수가 0이면 그대로 사용.
                                                                                            WHEN G.SC_YYYYWW_STD_WW_YN = 'Y' AND D.ACTUAL_RFLT_TYPE = 'DIST_EQUAL'      THEN NVL(H.SCM_YYYYWW_YYYY_TRG_SALE_QTY, 0) * (G.VER_PLAN_WORK_CNT / G.SCM_YYYYWW_WORK_CNT) -- 실적주차 : 균등이므로, 주차기준의 수량 합계를 남은 영업일수 비율만큼
                                                                                            WHEN G.SC_YYYYWW_STD_WW_YN = 'Y' AND D.ACTUAL_RFLT_TYPE = 'DIST_DIFF'       THEN NVL(H.SCM_YYYYWW_YYYY_TRG_SALE_QTY, 0) - NVL(H.VER_SCM_YYYYWW_ACTUAL_SALE_QTY, 0)      -- 실적주차 : 차액배분이므로, 주차기준의 계획 수량 합계에서 실적 수량 합계를 차감
                                                                                            WHEN G.SC_YYYYWW_STD_WW_YN = 'N'                                            THEN NVL(H.SCM_YYYYWW_YYYY_TRG_SALE_QTY, 0)                                                 -- 실적주차가 아니므로, 주차기준의 계획 수량 합계
                                                                                            ELSE 0
                                                                                       END      -- za. 영업일수가 0이면, 그냥 영업마트의 수량 그대로 사용. 아니면, 영업마트에서 남은 계획일수(영업일)만큼에 해당하는 금액 합산 추출
                                                                                       * CASE WHEN NVL(G.VER_PLAN_WORK_CNT, 0) = 0 OR NVL(G.SCM_YYYYWW_WORK_CNT, 0) = 0       THEN 1
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '2' THEN NVL(E.DOW_MON_RATE, 0)
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '3' THEN NVL(E.DOW_TUE_RATE, 0)
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '4' THEN NVL(E.DOW_WED_RATE, 0)
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '5' THEN NVL(E.DOW_THU_RATE, 0)
                                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '6' THEN NVL(E.DOW_FRI_RATE, 0)
                                                                                              ELSE 0
                                                                                         END    -- zb. 영업일수가 0이면, 1. 아니면, 해당 일자의 요일별판매비율
                                                                                       / CASE WHEN NVL(G.VER_PLAN_WORK_CNT, 0) = 0 OR NVL(G.SCM_YYYYWW_WORK_CNT, 0) = 0 THEN 1
                                                                                              WHEN (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '월') > 0 THEN NVL(E.DOW_MON_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '화') > 0 THEN NVL(E.DOW_TUE_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '수') > 0 THEN NVL(E.DOW_WED_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '목') > 0 THEN NVL(E.DOW_THU_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '금') > 0 THEN NVL(E.DOW_FRI_RATE, 0) ELSE 0 END) = 0 THEN G.VER_PLAN_WORK_CNT
                                                                                              ELSE (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '월') > 0 THEN NVL(E.DOW_MON_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '화') > 0 THEN NVL(E.DOW_TUE_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '수') > 0 THEN NVL(E.DOW_WED_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '목') > 0 THEN NVL(E.DOW_THU_RATE, 0) ELSE 0 END)
                                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '금') > 0 THEN NVL(E.DOW_FRI_RATE, 0) ELSE 0 END)
                                                                                         END    -- zc. 영업일수가 0이면, 1. 아니면, 남은 계획일수(영업일)에 해당하는 요일별판매비율 합산
                        ELSE 0
                   END
                   * CASE WHEN I.ITEM_CODE IS NULL THEN 1
                          ELSE                          NVL(I.SALE_VAR_VAL, 1)
                     END -- 판매변수값 적용
                   * CASE WHEN K.ITEM_MAP_YN = 'N'        THEN 1
                          WHEN J.FR_ITEM_CODE IS NOT NULL THEN J.CONVERSION_VALUE
                          ELSE                                 1
                     END -- 제품 매핑시에는 해당 To제품으로 환산
              )         AS AF_SALE_VAR_APL_SALE_QTY
         , 'N'          AS MODIFY_YN    -- 수정여부
         , MAX(
                   CASE WHEN B.YYYYMMDD <= A.STD_YYYYMMDD THEN 'ACTUAL'
                        ELSE                                   C.VAL
                   END
              )         AS SALE_TYPE    -- 판매유형 : 사용판매량 리스트(공통그룹코드=USE_SALE_QTY_LIST) + ACTUAL(실적) : ESPN_SALE(예상판매량), SALE_PLAN(판매계획), YYYY_TRG(경영계획), ACTUAL(실적)
         , MAX(I.SALE_VAR_DFNT_SEQNO)   AS SALE_VAR_DFNT_SEQNO              -- 판매변수정의 일련번호 : 여러 개가 적용되는 경우에는 하나만 표현
         , MAX(I.SALE_VAR_VAL)          AS SALE_VAR_VAL                     -- 판매변수값 : 여러 개가 적용되는 경우에는 누적값 표현
         , CASE WHEN K.ITEM_MAP_YN = 'Y' THEN '제품매핑 : ' || LISTAGG(NVL2(J.FR_ITEM_CODE, J.FR_ITEM_CODE || '(' || TRIM(TO_CHAR(J.CONVERSION_VALUE, '9,999,999,990.999')) || ')', F.ITEM_CODE || '(1)'), ' + ') WITHIN GROUP (ORDER BY J.FR_ITEM_CODE)
                WHEN K.ITEM_MAP_YN = 'N' THEN MAX('판매변수값 : ' || CASE WHEN I.ITEM_CODE IS NOT NULL THEN TRIM(TO_CHAR(NVL(I.SALE_VAR_VAL, 1), '9,999,999,990.999')) || '[' || I.SALE_VAR_DESC_LIST || ']' ELSE 'N/A' END)
                                              || ', '
                                              || MAX('마트의 판매량 : '
                                                        || CASE WHEN B.YYYYMMDD <= A.STD_YYYYMMDD                         THEN '실적' || '(일=' || TRIM(TO_CHAR(F.ACTUAL_SALE_QTY, '9,999,999,990.999')) || ')'
                                                                WHEN B.YYYYMMDD >  A.STD_YYYYMMDD AND C.VAL = 'ESPN_SALE' THEN '예상판매량' || '(일=' || TRIM(TO_CHAR(F.ESPN_SALE_QTY / DECODE(F.UOM_CONVERSION_VALUE, 0, NULL, F.UOM_CONVERSION_VALUE), '9,999,999,990.999')) || ', 주=' || TRIM(TO_CHAR(H.SCM_YYYYWW_ESPN_SALE_QTY, '9,999,999,990.999')) || ')'
                                                                WHEN B.YYYYMMDD >  A.STD_YYYYMMDD AND C.VAL = 'SALE_PLAN' THEN '예상판매량' || '(일=' || TRIM(TO_CHAR(F.MM_SALE_PLAN_QTY, '9,999,999,990.999')) || ', 주=' || TRIM(TO_CHAR(H.SCM_YYYYWW_MM_SALE_PLAN_QTY, '9,999,999,990.999')) || ')'
                                                                WHEN B.YYYYMMDD >  A.STD_YYYYMMDD AND C.VAL = 'YYYY_TRG'  THEN '예상판매량' || '(일=' || TRIM(TO_CHAR(F.YYYY_TRG_SALE_CONV_QTY / DECODE(F.UOM_CONVERSION_VALUE, 0, NULL, F.UOM_CONVERSION_VALUE), '9,999,999,990.999')) || ', 주=' || TRIM(TO_CHAR(H.SCM_YYYYWW_YYYY_TRG_SALE_QTY, '9,999,999,990.999')) || ')'
                                                           END
                                                    )
                                              || ', '
                                              || MAX('계획기간 요일별판매비율 : '
                                                        || TRIM(TO_CHAR(
                                                                         CASE WHEN NVL(G.VER_PLAN_WORK_CNT, 0) = 0 OR NVL(G.SCM_YYYYWW_WORK_CNT, 0) = 0       THEN 1
                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '2' THEN NVL(E.DOW_MON_RATE, 0)
                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '3' THEN NVL(E.DOW_TUE_RATE, 0)
                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '4' THEN NVL(E.DOW_WED_RATE, 0)
                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '5' THEN NVL(E.DOW_THU_RATE, 0)
                                                                              WHEN INSTR(G.VER_PLAN_DOW_LIST, B.DAY_OF_WEEK_DESC) > 0 AND B.DAY_OF_WEEK = '6' THEN NVL(E.DOW_FRI_RATE, 0)
                                                                              ELSE 0
                                                                         END
                                                                        , '990.999'))
                                                        || '(주간합산='
                                                        || TRIM(TO_CHAR(
                                                                         CASE WHEN NVL(G.VER_PLAN_WORK_CNT, 0) = 0 OR NVL(G.SCM_YYYYWW_WORK_CNT, 0) = 0 THEN 1
                                                                              WHEN (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '월') > 0 THEN NVL(E.DOW_MON_RATE, 0) ELSE 0 END)
                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '화') > 0 THEN NVL(E.DOW_TUE_RATE, 0) ELSE 0 END)
                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '수') > 0 THEN NVL(E.DOW_WED_RATE, 0) ELSE 0 END)
                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '목') > 0 THEN NVL(E.DOW_THU_RATE, 0) ELSE 0 END)
                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '금') > 0 THEN NVL(E.DOW_FRI_RATE, 0) ELSE 0 END) = 0 THEN G.VER_PLAN_WORK_CNT
                                                                              ELSE (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '월') > 0 THEN NVL(E.DOW_MON_RATE, 0) ELSE 0 END)
                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '화') > 0 THEN NVL(E.DOW_TUE_RATE, 0) ELSE 0 END)
                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '수') > 0 THEN NVL(E.DOW_WED_RATE, 0) ELSE 0 END)
                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '목') > 0 THEN NVL(E.DOW_THU_RATE, 0) ELSE 0 END)
                                                                                   + (CASE WHEN INSTR(G.VER_PLAN_DOW_LIST, '금') > 0 THEN NVL(E.DOW_FRI_RATE, 0) ELSE 0 END)
                                                                         END
                                                                        , '9,999,999,990.999'))
                                                        || ')'
                                                    )
                                              || ', '
                                              || MAX('계획기간 주차의 계획합계(요일별적용할때 분자값) : '
                                                        || TRIM(TO_CHAR(
                                                                           CASE WHEN B.YYYYMMDD >  A.STD_YYYYMMDD AND C.VAL = 'ESPN_SALE' THEN CASE WHEN NVL(G.VER_PLAN_WORK_CNT, 0) = 0 OR NVL(G.SCM_YYYYWW_WORK_CNT, 0) = 0   THEN NVL(F.ESPN_SALE_QTY / DECODE(F.UOM_CONVERSION_VALUE, 0, NULL, F.UOM_CONVERSION_VALUE), 0)  -- 주차의 영업일수가 0이면 그대로 사용. 영업예상량은 환산c/s로 들어있어서, 역산 처리
                                                                                                                                                    WHEN G.SC_YYYYWW_STD_WW_YN = 'Y' AND D.ACTUAL_RFLT_TYPE = 'DIST_EQUAL'      THEN NVL(H.SCM_YYYYWW_ESPN_SALE_QTY, 0) * (G.VER_PLAN_WORK_CNT / G.SCM_YYYYWW_WORK_CNT)         -- 실적주차 : 균등이므로, 주차기준의 수량 합계를 남은 영업일수 비율만큼
                                                                                                                                                    WHEN G.SC_YYYYWW_STD_WW_YN = 'Y' AND D.ACTUAL_RFLT_TYPE = 'DIST_DIFF'       THEN NVL(H.SCM_YYYYWW_ESPN_SALE_QTY, 0) - NVL(H.VER_SCM_YYYYWW_ACTUAL_SALE_QTY, 0)              -- 실적주차 : 차액배분이므로, 주차기준의 계획 수량 합계에서 실적 수량 합계를 차감
                                                                                                                                                    WHEN G.SC_YYYYWW_STD_WW_YN = 'N'                                            THEN NVL(H.SCM_YYYYWW_ESPN_SALE_QTY, 0)                                                         -- 실적주차가 아니므로, 주차기준의 계획 수량 합계
                                                                                                                                                    ELSE 0
                                                                                                                                               END      -- za. 영업일수가 0이면, 그냥 영업마트의 수량 그대로 사용. 아니면, 영업마트에서 남은 계획일수(영업일)만큼에 해당하는 금액 합산 추출
                                                                                WHEN B.YYYYMMDD >  A.STD_YYYYMMDD AND C.VAL = 'SALE_PLAN' THEN CASE WHEN NVL(G.VER_PLAN_WORK_CNT, 0) = 0 OR NVL(G.SCM_YYYYWW_WORK_CNT, 0) = 0   THEN NVL(F.MM_SALE_PLAN_QTY, 0)                                                            -- 주차의 영업일수가 0이면 그대로 사용.
                                                                                                                                                    WHEN G.SC_YYYYWW_STD_WW_YN = 'Y' AND D.ACTUAL_RFLT_TYPE = 'DIST_EQUAL'      THEN NVL(H.SCM_YYYYWW_MM_SALE_PLAN_QTY, 0) * (G.VER_PLAN_WORK_CNT / G.SCM_YYYYWW_WORK_CNT) -- 실적주차 : 균등이므로, 주차기준의 수량 합계를 남은 영업일수 비율만큼
                                                                                                                                                    WHEN G.SC_YYYYWW_STD_WW_YN = 'Y' AND D.ACTUAL_RFLT_TYPE = 'DIST_DIFF'       THEN NVL(H.SCM_YYYYWW_MM_SALE_PLAN_QTY, 0) - NVL(H.VER_SCM_YYYYWW_ACTUAL_SALE_QTY, 0)      -- 실적주차 : 차액배분이므로, 주차기준의 계획 수량 합계에서 실적 수량 합계를 차감
                                                                                                                                                    WHEN G.SC_YYYYWW_STD_WW_YN = 'N'                                            THEN NVL(H.SCM_YYYYWW_MM_SALE_PLAN_QTY, 0)                                                 -- 실적주차가 아니므로, 주차기준의 계획 수량 합계
                                                                                                                                                    ELSE 0
                                                                                                                                               END      -- za. 영업일수가 0이면, 그냥 영업마트의 수량 그대로 사용. 아니면, 영업마트에서 남은 계획일수(영업일)만큼에 해당하는 금액 합산 추출
                                                                                WHEN B.YYYYMMDD >  A.STD_YYYYMMDD AND C.VAL = 'YYYY_TRG'  THEN CASE WHEN NVL(G.VER_PLAN_WORK_CNT, 0) = 0 OR NVL(G.SCM_YYYYWW_WORK_CNT, 0) = 0   THEN NVL(F.YYYY_TRG_SALE_CONV_QTY / DECODE(F.UOM_CONVERSION_VALUE, 0, NULL, F.UOM_CONVERSION_VALUE), 0) -- 주차의 영업일수가 0이면 그대로 사용.
                                                                                                                                                    WHEN G.SC_YYYYWW_STD_WW_YN = 'Y' AND D.ACTUAL_RFLT_TYPE = 'DIST_EQUAL'      THEN NVL(H.SCM_YYYYWW_YYYY_TRG_SALE_QTY, 0) * (G.VER_PLAN_WORK_CNT / G.SCM_YYYYWW_WORK_CNT) -- 실적주차 : 균등이므로, 주차기준의 수량 합계를 남은 영업일수 비율만큼
                                                                                                                                                    WHEN G.SC_YYYYWW_STD_WW_YN = 'Y' AND D.ACTUAL_RFLT_TYPE = 'DIST_DIFF'       THEN NVL(H.SCM_YYYYWW_YYYY_TRG_SALE_QTY, 0) - NVL(H.VER_SCM_YYYYWW_ACTUAL_SALE_QTY, 0)      -- 실적주차 : 차액배분이므로, 주차기준의 계획 수량 합계에서 실적 수량 합계를 차감
                                                                                                                                                    WHEN G.SC_YYYYWW_STD_WW_YN = 'N'                                            THEN NVL(H.SCM_YYYYWW_YYYY_TRG_SALE_QTY, 0)                                                 -- 실적주차가 아니므로, 주차기준의 계획 수량 합계
                                                                                                                                                    ELSE 0
                                                                                                                                               END      -- za. 영업일수가 0이면, 그냥 영업마트의 수량 그대로 사용. 아니면, 영업마트에서 남은 계획일수(영업일)만큼에 해당하는 금액 합산 추출
                                                                                ELSE 0
                                                                           END
                                                                        , '9,999,999,990.999'))
                                                        || ')'
                                                    )
                                              || MAX(CASE WHEN G.SC_YYYYWW_STD_WW_YN = 'Y' THEN ', ' || '실적주차의 반영방법 : ' || D.ACTUAL_RFLT_TYPE END)

           END          AS RMKS
         , NULL AS ATTRIBUTE1, NULL AS ATTRIBUTE2, NULL AS ATTRIBUTE3, NULL AS ATTRIBUTE4, NULL AS ATTRIBUTE5
         , #{userId, jdbcType=VARCHAR}, SYSDATE, #{userId, jdbcType=VARCHAR}, SYSDATE
/*
         , A.STD_YYYYMMDD, A.VER_FR_DT, A.VER_TO_DT, TO_DATE(A.VER_TO_DT, 'YYYYMMDD') - TO_DATE(A.VER_FR_DT, 'YYYYMMDD') + 1 AS DIF_DT
         , B.SCM_YYYYWW
         , C.VAL        AS USE_SALE_QTY_CODE                                -- 사용판매량 리스트(공통그룹코드=USE_SALE_QTY_LIST) : ESPN_SALE(예상판매량), SALE_PLAN(판매계획), YYYY_TRG(경영계획)
         , D.ACTUAL_RFLT_TYPE                                               -- 사업부문별 실적주차의 실적반영유형 : DIST_DIFF(차액배분 : 판매계획과 실적의 차이를 나눠서 배분), DIST_EQUAL(균등 : 판매계획을 영업일수로 나눈 값을 그대로 반영)
         , F.YYYY_TRG_SALE_QTY, F.MM_SALE_PLAN_QTY, F.ESPN_SALE_QTY / DECODE(F.UOM_CONVERSION_VALUE, 0, NULL, F.UOM_CONVERSION_VALUE) AS ESPN_SALE_QTY -- 영업예상량은 환산c/s로 들어있어서, 역산 처리
         , G.SC_YYYYWW_STD_WW_YN                                            -- 실적주차 여부 : 기준일자(실적일자)가 포함된 주차 여부
         , G.SCM_YYYYWW_FR_DT, G.SCM_YYYYWW_TO_DT, G.SCM_YYYYWW_WORK_CNT    -- 주차의 영업일수
         , G.ACTUAL_WORK_CNT, G.PLAN_WORK_CNT, G.PLAN_DOW_LIST              -- 기준일자가 포함된 주차의 실적/계획 영업일수 
         , G.VER_ACTUAL_WORK_CNT, G.VER_PLAN_WORK_CNT, G.VER_PLAN_DOW_LIST  -- 주차의 (버전 기간을 고려한)영업일수, 기준일자가 포함된 주차의 실적/계획 (버전 기간을 고려한)영업일수
         , H.SCM_YYYYWW_YYYY_TRG_SALE_QTY, H.SCM_YYYYWW_WW_SALE_PLAN_QTY, H.SCM_YYYYWW_MM_SALE_PLAN_QTY, H.SCM_YYYYWW_ESPN_SALE_QTY
         , I.SALE_VAR_DFNT_SEQNO_LIST, I.SALE_VAR_DESC_LIST                 -- 판매변수가 여러개일 경우의 표현
*/
      FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_M           A
      JOIN SCMU.W_SOP_VW_CALENDAR_M                 B
        ON B.YYYYMMDD BETWEEN A.VER_FR_DT AND A.VER_TO_DT
                -- C. 사업부문/월별 사용하는 판매계획 설정
      JOIN SCMU.W_SOP_TB_DALY_SCM_SIMUL_SALE_SET_M  C
        ON C.VER_CD              = A.VER_CD
       AND C.SALE_SET_TYPE_CODE  = 'USE_SALE_QTY' -- 사용판매량(USE_SALE_QTY)
       AND B.YYYYMMDD LIKE C.USE_SALE_QTY_YYYYMM || '__'
 LEFT JOIN (    -- D. 사업부문별 실적주차의 실적반영유형 : 공통그룹코드=ACTUAL_RFLT_TYPE_LIST 참고 : DIST_DIFF(차액배분 : 판매계획과 실적의 차이를 나눠서 배분), DIST_EQUAL(균등 : 판매계획을 영업일수로 나눈 값을 그대로 반영)
                SELECT VER_CD, LIQUOR_CODE, MAX(VAL) AS ACTUAL_RFLT_TYPE
                  FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_SALE_SET_M
                 WHERE 1 = 1
                   AND VER_CD = #{verCd, jdbcType=VARCHAR}
                   AND SALE_SET_TYPE_CODE = 'ACTUAL_RFLT_TYPE' -- 실적반영유형(ACTUAL_RFLT_TYPE)
                 GROUP BY VER_CD, LIQUOR_CODE
           )                                        D
        ON D.VER_CD      = A.VER_CD
       AND D.LIQUOR_CODE = C.LIQUOR_CODE
 LEFT JOIN (    -- E. 사업부문별 요일별 판매비율 : 판매계획의 주차별 합산을 요일에 반영하는 비율
                SELECT VER_CD, LIQUOR_CODE
                     , MAX(CASE WHEN DOW_CODE = 'MON' THEN TO_NUMBER(NVL(VAL, 0)) END) AS DOW_MON_RATE
                     , MAX(CASE WHEN DOW_CODE = 'TUE' THEN TO_NUMBER(NVL(VAL, 0)) END) AS DOW_TUE_RATE
                     , MAX(CASE WHEN DOW_CODE = 'WED' THEN TO_NUMBER(NVL(VAL, 0)) END) AS DOW_WED_RATE
                     , MAX(CASE WHEN DOW_CODE = 'THU' THEN TO_NUMBER(NVL(VAL, 0)) END) AS DOW_THU_RATE
                     , MAX(CASE WHEN DOW_CODE = 'FRI' THEN TO_NUMBER(NVL(VAL, 0)) END) AS DOW_FRI_RATE
                  FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_SALE_SET_M
                 WHERE 1 = 1
                   AND VER_CD = #{verCd, jdbcType=VARCHAR}
                   AND SALE_SET_TYPE_CODE = 'DOW_SALE_RATE' -- 실적반영유형(ACTUAL_RFLT_TYPE)
                 GROUP BY VER_CD, LIQUOR_CODE
           )                                        E
        ON E.VER_CD      = A.VER_CD
       AND E.LIQUOR_CODE = C.LIQUOR_CODE
                -- F. 제품 판매 마트 : 실적과 각 주차의 제품 리스트 생성을 위해서 사용. 실적주차와 나머지 계획들은 하단에서 주차별로 재계산
      JOIN SCMU.M_SOP_TB_ITEM_SALE_F                F
        ON F.PERIOD_YYYYMMDD = B.YYYYMMDD
       AND F.LIQUOR_CODE     = C.LIQUOR_CODE
       AND F.ITEM_TYPE       = 'FG'
 LEFT JOIN (    -- G. 버전의 기간내에 존재하는 주차의 정보 추출 : 기간의 시작/종료가 주차내에 걸칠 때, 기간내만 영업일수 계산
                SELECT GA.VER_CD, GB.YYYYMM, GB.SCM_YYYYWW AS SCM_YYYYWW, MIN(GB.YYYYMMDD) AS SCM_YYYYWW_FR_DT, MAX(GB.YYYYMMDD) AS SCM_YYYYWW_TO_DT
                     , CASE WHEN MAX(GA.STD_YYYYMMDD) BETWEEN MIN(GB.YYYYMMDD) AND MAX(GB.YYYYMMDD) THEN 'Y'
                            ELSE                                                                         'N'
                       END AS SC_YYYYWW_STD_WW_YN -- 실적주차 여부 : 기준일자(실적일자)가 포함된 주차 여부
                     , SUM(CASE WHEN GB.BUSINESS_DAY_FLAG = 'Y'                                                                                          THEN 1 ELSE 0 END)                                                             AS SCM_YYYYWW_WORK_CNT
                     , SUM(CASE WHEN GB.BUSINESS_DAY_FLAG = 'Y' AND GB.YYYYMMDD <= GA.STD_YYYYMMDD                                                       THEN 1 ELSE 0 END)                                                             AS ACTUAL_WORK_CNT
                     , SUM(CASE WHEN GB.BUSINESS_DAY_FLAG = 'Y' AND GB.YYYYMMDD >  GA.STD_YYYYMMDD                                                       THEN 1 ELSE 0 END)                                                             AS PLAN_WORK_CNT
                     , LISTAGG(CASE WHEN GB.BUSINESS_DAY_FLAG = 'Y' AND GB.YYYYMMDD > GA.STD_YYYYMMDD                                                       THEN GB.DAY_OF_WEEK_DESC ELSE '' END) WITHIN GROUP (ORDER BY GB.YYYYMMDD)   AS PLAN_DOW_LIST
                     , SUM(CASE WHEN GB.BUSINESS_DAY_FLAG = 'Y' AND GB.YYYYMMDD <= GA.STD_YYYYMMDD AND GB.YYYYMMDD BETWEEN GA.VER_FR_DT AND GA.VER_TO_DT THEN 1 ELSE 0 END)                                                             AS VER_ACTUAL_WORK_CNT
                     , SUM(CASE WHEN GB.BUSINESS_DAY_FLAG = 'Y' AND GB.YYYYMMDD >  GA.STD_YYYYMMDD AND GB.YYYYMMDD BETWEEN GA.VER_FR_DT AND GA.VER_TO_DT THEN 1 ELSE 0 END)                                                             AS VER_PLAN_WORK_CNT
                     , LISTAGG(CASE WHEN GB.BUSINESS_DAY_FLAG = 'Y' AND GB.YYYYMMDD > GA.STD_YYYYMMDD AND GB.YYYYMMDD BETWEEN GA.VER_FR_DT AND GA.VER_TO_DT THEN GB.DAY_OF_WEEK_DESC ELSE '' END) WITHIN GROUP (ORDER BY GB.YYYYMMDD)   AS VER_PLAN_DOW_LIST
                  FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_M GA
                  JOIN SCMU.W_SOP_VW_CALENDAR_M       GB
                    ON GB.YYYYMMDD BETWEEN TO_CHAR(TO_DATE(GA.VER_FR_DT, 'YYYYMMDD') + (-1 * TO_NUMBER(TO_CHAR(TO_DATE(GA.VER_FR_DT, 'YYYYMMDD'), 'D')) + 1), 'YYYYMMDD')
                                       AND TO_CHAR(TO_DATE(GA.VER_TO_DT, 'YYYYMMDD') + (-1 * TO_NUMBER(TO_CHAR(TO_DATE(GA.VER_TO_DT, 'YYYYMMDD'), 'D')) + 1) + 6, 'YYYYMMDD')
                 WHERE 1 = 1
                   AND GA.VER_CD          = #{verCd, jdbcType=VARCHAR}
                 GROUP BY GA.VER_CD, GB.YYYYMM, GB.SCM_YYYYWW
           )                                        G
        ON G.VER_CD     = A.VER_CD
       AND G.YYYYMM     = B.YYYYMM
       AND G.SCM_YYYYWW = B.SCM_YYYYWW
 LEFT JOIN (    -- H. 주차별 연간목표, 판매계획, 예상판매량
                SELECT HA.VER_CD, HB.PERIOD_YYYYMM AS YYYYMM, HB.PERIOD_SCM_YYYYWW AS SCM_YYYYWW, HB.ITEM_CODE, HB.LIQUOR_CODE
                     , SUM(CASE WHEN HA.STD_YYYYMMDD >= HB.PERIOD_YYYYMMDD THEN HB.ACTUAL_SALE_QTY ELSE 0 END) AS VER_SCM_YYYYWW_ACTUAL_SALE_QTY
                     , SUM(HB.YYYY_TRG_SALE_CONV_QTY / DECODE(HB.UOM_CONVERSION_VALUE, 0, NULL, HB.UOM_CONVERSION_VALUE)) AS SCM_YYYYWW_YYYY_TRG_SALE_QTY
                     , SUM(HB.WW_SALE_PLAN_QTY)     AS SCM_YYYYWW_WW_SALE_PLAN_QTY
                     , SUM(HB.MM_SALE_PLAN_QTY)     AS SCM_YYYYWW_MM_SALE_PLAN_QTY
                     , SUM(HB.ESPN_SALE_QTY / DECODE(HB.UOM_CONVERSION_VALUE, 0, NULL, HB.UOM_CONVERSION_VALUE))    AS SCM_YYYYWW_ESPN_SALE_QTY -- 영업예상량은 환산c/s로 들어있어서, 역산 처리
                  FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_M HA
                  JOIN SCMU.M_SOP_TB_ITEM_SALE_F      HB
                    ON HB.PERIOD_YYYYMMDD BETWEEN TO_CHAR(TO_DATE(HA.STD_YYYYMMDD, 'YYYYMMDD') + (-1 * TO_NUMBER(TO_CHAR(TO_DATE(HA.STD_YYYYMMDD, 'YYYYMMDD'), 'D')) + 1), 'YYYYMMDD')
                                              AND TO_CHAR(TO_DATE(HA.VER_TO_DT, 'YYYYMMDD') + (-1 * TO_NUMBER(TO_CHAR(TO_DATE(HA.VER_TO_DT, 'YYYYMMDD'), 'D')) + 1) + 6, 'YYYYMMDD')
                 WHERE 1 = 1
                   AND HA.VER_CD      = #{verCd, jdbcType=VARCHAR}
                   AND HB.ITEM_TYPE   = 'FG'
                   AND HB.LIQUOR_CODE IN ('10', '20')
                   AND (HB.YYYY_TRG_SALE_CONV_QTY != 0 OR HB.WW_SALE_PLAN_QTY != 0 OR HB.MM_SALE_PLAN_QTY != 0 OR HB.ESPN_SALE_QTY != 0)
                 GROUP BY HA.VER_CD, HB.PERIOD_YYYYMM, HB.PERIOD_SCM_YYYYWW, HB.ITEM_CODE, HB.LIQUOR_CODE
           )                                        H
        ON H.VER_CD     = A.VER_CD
       AND H.YYYYMM     = B.YYYYMM
       AND H.SCM_YYYYWW = B.SCM_YYYYWW
       AND H.ITEM_CODE  = F.ITEM_CODE
 LEFT JOIN (    -- I. 판매변수 적용되는 제품과 적용값
                SELECT IA.VER_CD, IB.YYYYMMDD, ID.ITEM_CODE
                     , MIN(TO_NUMBER(IC.VAL))                               AS SALE_VAR_DFNT_SEQNO      -- 판매변수정의 일련번호 : 여러개가 적용되면, 그중 하나
                     , EXP(SUM(LN(IC.SALE_VAR_VAL)))                        AS SALE_VAR_VAL             -- 판매변수값 누적
                     , LISTAGG(IC.VAL, ',') WITHIN GROUP (ORDER BY IC.VAL)  AS SALE_VAR_DFNT_SEQNO_LIST -- 판매변수정의 일련번호 리스트
                     , LISTAGG(IC.SALE_VAR_NAME || '(' || TRIM(TO_CHAR(IC.SALE_VAR_VAL, '990.999')) || ')', ',') WITHIN GROUP (ORDER BY IC.VAL)  AS SALE_VAR_DESC_LIST -- 판매변수설명 리스트
                     --, IC.SALE_VAR_APL_FR_DT, IC.SALE_VAR_APL_TO_DT, IC.SALE_VAR_NAME, IC.SALE_VAR_TYPE, IC.LIQUOR_CODE, IC.SALE_VAR_USAGE_CODE, IC.SALE_VAR_ITEM_CODE
                  FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_M          IA
                  JOIN SCMU.W_SOP_VW_CALENDAR_M                IB
                    ON IB.YYYYMMDD BETWEEN IA.VER_FR_DT AND IA.VER_TO_DT
                  JOIN SCMU.W_SOP_TB_DALY_SCM_SIMUL_SALE_SET_M IC
                    ON IC.VER_CD             = IA.VER_CD
                   AND IC.SALE_SET_TYPE_CODE = 'SALE_VAR' -- 판매변수(SALE_VAR)
                   AND IB.YYYYMMDD BETWEEN IC.SALE_VAR_APL_FR_DT AND IC.SALE_VAR_APL_TO_DT -- 판매변수 적용 기간
                  JOIN SCMU.M_SOP_TB_ITEM_SALE_F               ID
                    ON ID.PERIOD_YYYYMMDD = IB.YYYYMMDD
                   AND ID.ITEM_TYPE       = 'FG'
                   AND ID.LIQUOR_CODE     IN ('10', '20')
                   AND (ID.YYYY_TRG_SALE_CONV_QTY != 0 OR ID.WW_SALE_PLAN_QTY != 0 OR ID.MM_SALE_PLAN_QTY != 0 OR ID.ESPN_SALE_QTY != 0) -- 사용할 계획이 존재하는 제품만 대상
                       -- 판매변수의 적용대상 체크
                   AND (IC.LIQUOR_CODE = '!ALL' OR ID.LIQUOR_CODE = IC.LIQUOR_CODE)
                   AND (IC.SALE_VAR_USAGE_CODE = '!ALL' OR ID.USAGE_CODE = IC.SALE_VAR_USAGE_CODE)
                   AND (IC.SALE_VAR_ITEM_CODE = '!ALL' OR ID.ITEM_CODE = IC.SALE_VAR_ITEM_CODE)
                 WHERE 1 = 1
                   AND IA.VER_CD          = #{verCd, jdbcType=VARCHAR}
                 GROUP BY IA.VER_CD, IB.YYYYMMDD, ID.ITEM_CODE
           )                                        I
        ON I.VER_CD    = A.VER_CD
       AND I.YYYYMMDD  = B.YYYYMMDD
       AND I.ITEM_CODE = F.ITEM_CODE
                -- J. 제품매핑 리스트
 LEFT JOIN SCMU.W_SOP_TB_ITEM_MAP_M                 J
        ON J.FR_ITEM_CODE = F.ITEM_CODE
CROSS JOIN (    -- K. 제품매핑 Y/N 생성용
                SELECT 'Y' AS ITEM_MAP_YN FROM DUAL UNION ALL
                SELECT 'N' AS ITEM_MAP_YN FROM DUAL
           )                                        K
     WHERE 1 = 1
       AND A.VER_CD      = #{verCd, jdbcType=VARCHAR}
       AND C.LIQUOR_CODE = #{liquorCode, jdbcType=VARCHAR}
       AND CASE WHEN B.YYYYMMDD <= A.STD_YYYYMMDD                         THEN NVL(F.ACTUAL_SALE_QTY, 0)
                WHEN B.YYYYMMDD >  A.STD_YYYYMMDD AND C.VAL = 'ESPN_SALE' THEN NVL(F.ESPN_SALE_QTY, 0)
                WHEN B.YYYYMMDD >  A.STD_YYYYMMDD AND C.VAL = 'SALE_PLAN' THEN NVL(F.MM_SALE_PLAN_QTY, 0)
                WHEN B.YYYYMMDD >  A.STD_YYYYMMDD AND C.VAL = 'YYYY_TRG'  THEN NVL(F.YYYY_TRG_SALE_CONV_QTY / DECODE(F.UOM_CONVERSION_VALUE, 0, NULL, F.UOM_CONVERSION_VALUE), 0)
                ELSE 0
           END != 0
     GROUP BY A.VER_CD, K.ITEM_MAP_YN, C.LIQUOR_CODE, B.YYYYMMDD
            , CASE WHEN K.ITEM_MAP_YN = 'N' THEN F.ITEM_CODE WHEN J.FR_ITEM_CODE IS NOT NULL THEN J.TO_ITEM_CODE ELSE F.ITEM_CODE END
     ORDER BY K.ITEM_MAP_YN, C.LIQUOR_CODE, B.YYYYMMDD
        ]]>
    </update>
    
    <!-- 판매설정 - 판매량 초기화 : 삭제 -->
    <delete id="deleteSale" parameterType="map">
DELETE /* com.hitejinro.snop.work.dao.M02020DaoMapper.deleteSale */
  FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_SALE_F T
 WHERE 1 = 1
   AND T.VER_CD      = #{verCd, jdbcType=VARCHAR}
   AND T.LIQUOR_CODE = #{liquorCode, jdbcType=VARCHAR}
    </delete>





    <!-- 생산변수의 공장/라인/제품별 단위생산량 조회 -->
    <select id="selectPrdtVarDtlList" parameterType="map" resultType="map">
SELECT /* com.hitejinro.snop.work.dao.M02020DaoMapper.selectPrdtVarDtlList */
       B.ORG_CODE || '|' || B.LINE_DEPT_CODE || '|' || B.ITEM_CODE AS PK
     , A.VER_CD, B.PRDT_VAR_VER_CD
     , B.ORG_CODE, B.LINE_DEPT_CODE, B.ITEM_CODE
     , NVL(B.QTY_PER_HOUR, 0) * NVL(B.PRDT_EFC_RATE, 1) AS QTY_PER_HR -- 생산효율이 감안된 시간당 생산량(단순c/s)
     , B.WORK_SFT_TEXT, B.QTY_PER_HOUR, B.QTY_PER_MIN, B.PRDT_EFC_RATE, B.PRDT_RANK, B.LINE_DEPT_NAME, B.NEW_LINE_YN, B.VESSEL_CODE, B.VOLUME_VALUE, B.ACTUAL_60D_SALE_QTY, B.UOM_CONVERSION_VALUE
  FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_M  A
  JOIN SCMU.W_SOP_TB_PRDT_VAR_DTL_M    B
    ON B.PRDT_VAR_VER_CD = A.PRDT_VAR_VER_CD
 WHERE 1 = 1
   AND A.VER_CD = #{verCd, jdbcType=VARCHAR}
 ORDER BY B.ORG_CODE, B.LINE_DEPT_CODE, B.ITEM_CODE
    </select>

    <!-- 결과설정의 그리드 헤더 조회 : (시뮬레이션 결과 + 생산변수에 정의된 공장/라인/제품)과 계정의 조합 리스트 -->
    <select id="searchResultHeader" parameterType="map" resultType="map">
/* 제품:[판매, (월별 일평균판매량), 생산(생산량합계, 공장/라인의 생산량, 재고, 재고일수], 생산시간 체크:[공장/라인의 가용시간/사용시간]
"테라 유흥 중 20P                                                               "    …    "가용 생산 시간 체크        "   
판매    "생산                                                    재고    재고일수          "강원                   …      
        생산량합계    "강원          "   "전주          "  ...                             "병1호              "
                       병1호    병2호     병1호    병2호                                   가용시간    사용시간
*/
    -- 1. 제품별 판매/생산/재고 리스트
    SELECT /* com.hitejinro.snop.work.dao.M02020DaoMapper.searchResultHeader */
           A.VER_CD, B.LIQUOR_CODE
         , D.COL_GUBUN                                      -- COL구분 : ITEM-SALE_QTY, ITEM-SALE_AVG_QTY, ITEM-PRDT-TOTAL_PRDT_QTY, ITEM-PRDT-LINE-PRDT_QTY, ITEM-PRDT-LINE-USE_HR, ITEM-STOCK_QTY, ITEM-STOCK_DCNT
         , D.COL_VISIBLE, D.COL_WIDTH, D.COL_TYPE, D.COL_FORMAT, D.COL_ALIGN, D.COL_CAN_EDIT, D.COL_SEQ
         
         , C.DESCRIPTION                AS HEADER1_NM       -- 헤더 1행 표현 : 제품명칭 리스트, 생산시간 체크
         , 1                            AS HEADER1_ROWSPAN  -- 헤더 1행 RowSpan : 1로 고정
         , COUNT(1) OVER (PARTITION BY B.ITEM_CODE)
                                        AS HEADER1_COLSPAN  -- 헤더 1행 ColSpan : 제품명칭은 판매(1)+일평균판매량(1)+생산량합계(1)+공장/라인리스트(?)*생산량/사용시간(2)+재고(1)+재고일수(1). 생산시간은 공장/라인리스트(?) * 가용시간/사용시간(2)
         
         , CASE WHEN ROW_NUMBER() OVER (PARTITION BY C.DESCRIPTION || D.HEADER2_NM ORDER BY D.COL_SEQ) = 1 THEN D.HEADER2_NM
                ELSE TO_CHAR(NULL)
           END                          AS HEADER2_NM       -- 헤더 2행 : 제품명칭 밑에 판매, 생산, 재고, 재고일수. 생산시간 밑에 공장명칭
         , CASE WHEN D.COL_GUBUN IN ('ITEM-SALE_QTY', 'ITEM-STOCK_QTY', 'ITEM-STOCK_DCNT') THEN 3
                ELSE 1
           END                          AS HEADER2_ROWSPAN  -- 헤더 2행 RowSpan : 제품-판매는 3으로 고정. 제품-생산은 1로 고정. 제품-재고/재고일수는 3으로 고정. 생산시간-공장은 1로 고정
         , CASE WHEN ROW_NUMBER() OVER (PARTITION BY C.DESCRIPTION || D.HEADER2_NM ORDER BY D.COL_SEQ) = 1 THEN COUNT(1) OVER (PARTITION BY C.DESCRIPTION || D.HEADER2_NM)
                ELSE 1
           END                          AS HEADER2_COLSPAN  -- 헤더 2행 ColSpan : 제품-판매는 1로 고정. 제품-생산은 생산량합계(1)+공장/라인리스트(?)*생산량/사용시간(2). 제품-재고/재고일수는 1로 고정. 생산시간-공장은 라인리스트(?) * 가용시간/사용시간(2)
         
         , CASE WHEN ROW_NUMBER() OVER (PARTITION BY C.DESCRIPTION || D.HEADER2_NM || D.HEADER3_NM ORDER BY D.COL_SEQ) = 1 THEN D.HEADER3_NM
                ELSE TO_CHAR(NULL)
           END                          AS HEADER3_NM       -- 헤더 3행 : 제품-생산 밑에 공장명칭. 생산시간-공장 밑에 라인명칭
         , CASE WHEN D.COL_GUBUN IN ('ITEM-PRDT-TOTAL_PRDT_QTY') THEN 3
                ELSE 1
           END                          AS HEADER3_ROWSPAN  -- 헤더 3행 RowSpan : 1은 표현 제외. 제품-생산-생산량합계는 2로 고정
         , CASE WHEN ROW_NUMBER() OVER (PARTITION BY C.DESCRIPTION || D.HEADER2_NM || D.HEADER3_NM ORDER BY D.COL_SEQ) = 1 THEN COUNT(1) OVER (PARTITION BY C.DESCRIPTION || D.HEADER2_NM || D.HEADER3_NM)
                ELSE 1
           END                          AS HEADER3_COLSPAN  -- 헤더 3행 ColSpan : 1은 표현 제외. 제품-생산-공장은 라인리스트(?)*생산량/사용시간(2). 생산시간-공장-라인은 2로 고정(가용시간/사용시간)
         
         , D.HEADER4_NM                 AS HEADER4_NM       -- 헤더 4행 : 제품-생산-공장 밑에 라인명칭(생산량/사용시간). 생산시간-공장-라인 밑에 가용시간, 사용시간
         , 1                            AS HEADER4_ROWSPAN  -- 헤더 4행 RowSpan : 모두 1로 고정(즉, 표현 불필요)
         , 1                            AS HEADER4_COLSPAN  -- 헤더 4행 ColSpan : 모두 1로 고정(즉, 표현 불필요)
         
         , B.ITEM_CODE, C.DESCRIPTION AS ITEM_NAME
         , C.BRAND_CODE, C.BRAND_NAME, C.BRAND_SORT_ORDER, C.VESSEL_CODE, C.VESSEL_SORT, C.VESSEL_SORT_ORDER, C.USAGE_CODE, C.USAGE_NAME, C.USAGE_SORT_ORDER, C.VOLUME_VALUE, C.DOM_EXP_CODE, C.DOM_EXP_FLAG
         , D.ORG_CODE, D.ORG_NAME, D.LINE_DEPT_CODE, D.LINE_DEPT_NAME
         -- 판매량 많은 것부터. 수출은 뒤로. 브랜드 / 제품명 순
         , 'COL_' || (10000 + ROW_NUMBER() OVER (PARTITION BY A.VER_CD ORDER BY B.LIQUOR_CODE, B.SALE_CONV_QTY DESC, DECODE(C.DOM_EXP_CODE, '1', -1, 1), C.BRAND_SORT_ORDER, C.BRAND_NAME, C.DESCRIPTION, B.ITEM_CODE, D.COL_SEQ)) AS COL_ID

      FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_M       A
      JOIN (    -- B. 제품 리스트 : 판매+생산+재고 리스트
                SELECT VER_CD, LIQUOR_CODE, ITEM_CODE, SUM(NVL(SALE_CONV_QTY, 0)) AS SALE_CONV_QTY
                  FROM (
                            SELECT BA.VER_CD, BA.LIQUOR_CODE, BA.ITEM_CODE, SUM(BA.SALE_QTY * BB.UOM_CONVERSION_VALUE) AS SALE_CONV_QTY
                              FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_SALE_F BA
                         LEFT JOIN EDW.W_CM_TB_FG_ITEM_M               BB
                                ON BB.ITEM_CODE = BA.ITEM_CODE
                             WHERE 1 = 1
                               AND BA.VER_CD      = #{verCd, jdbcType=VARCHAR}
                               AND BA.ITEM_MAP_YN = 'Y' -- 제품매핑여부=Y : N은 검증용이니, 실제 사용하는 Y(모제품 매핑 후)를 사용
                               AND BA.LIQUOR_CODE = #{liquorCode, jdbcType=VARCHAR}
                               AND NVL(BA.SALE_QTY, 0) != 0 -- 판매량이 존재하는 것만 표현
                             GROUP BY BA.VER_CD, BA.LIQUOR_CODE, BA.ITEM_CODE
                             UNION ALL
                            SELECT DISTINCT VER_CD, LIQUOR_CODE, ITEM_CODE, 0 AS SALE_CONV_QTY
                              FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_RESULT_F
                             WHERE 1 = 1
                               AND VER_CD      = #{verCd, jdbcType=VARCHAR}
                               AND LIQUOR_CODE = #{liquorCode, jdbcType=VARCHAR}
                               AND NVL(PRDT_QTY, 0) != 0 -- 생산이 존재하는 것만 표현
                       )
                 WHERE 1 = 1
                 GROUP BY VER_CD, LIQUOR_CODE, ITEM_CODE
           )  B
        ON B.VER_CD      = A.VER_CD
 LEFT JOIN EDW.W_CM_TB_FG_ITEM_M                C
        ON C.ITEM_CODE = B.ITEM_CODE
      JOIN (    -- D. 제품별 판매/생산/재고 리스트 강제 생성
                SELECT 'ITEM-SALE_QTY' AS COL_GUBUN, '판매' AS HEADER2_NM, NULL AS HEADER3_NM, NULL AS HEADER4_NM
                     , 1 AS COL_VISIBLE, 70 AS COL_WIDTH, 'Float' AS COL_TYPE, ',0' AS COL_FORMAT, 'Right' AS COL_ALIGN, 0 AS COL_CAN_EDIT, 111000 AS COL_SEQ
                     , '-' AS ORG_CODE, '-' AS ORG_NAME, '-' AS LINE_DEPT_CODE, '-' AS LINE_DEPT_NAME, '!ALL' AS VESSEL_LIST, '!ALL' AS ITEM_CODE_LIST
                  FROM DUAL
                 UNION ALL
                SELECT 'ITEM-SALE_AVG_QTY' AS COL_GUBUN, '일평균판매' AS HEADER2_NM, NULL AS HEADER3_NM, NULL AS HEADER4_NM
                     , 0 AS COL_VISIBLE, 70 AS COL_WIDTH, 'Float' AS COL_TYPE, ',0' AS COL_FORMAT, 'Right' AS COL_ALIGN, 0 AS COL_CAN_EDIT, 112000 AS COL_SEQ
                     , '-' AS ORG_CODE, '-' AS ORG_NAME, '-' AS LINE_DEPT_CODE, '-' AS LINE_DEPT_NAME, '!ALL' AS VESSEL_LIST, '!ALL' AS ITEM_CODE_LIST
                  FROM DUAL
                 UNION ALL
                SELECT 'ITEM-PRDT-TOTAL_PRDT_QTY' AS COL_GUBUN, '생산' AS HEADER2_NM, '생산량' || CHR(13) || CHR(10) || '합계' AS HEADER3_NM, NULL AS HEADER4_NM
                     , 1 AS COL_VISIBLE, 70 AS COL_WIDTH, 'Float' AS COL_TYPE, ',0' AS COL_FORMAT, 'Right' AS COL_ALIGN, 0 AS COL_CAN_EDIT, 121000 AS COL_SEQ
                     , '-' AS ORG_CODE, '-' AS ORG_NAME, '-' AS LINE_DEPT_CODE, '-' AS LINE_DEPT_NAME, '!ALL' AS VESSEL_LIST, '!ALL' AS ITEM_CODE_LIST
                  FROM DUAL
                 UNION ALL
                -- 공장/라인 리스트 * 생산량/사용시간 : 시뮬레이션 결과 + 생산변수(단위 생산량 존재)
                SELECT 'ITEM-PRDT-LINE-' || ACCT_CD                                 AS COL_GUBUN -- "ITEM-PRDT-LINE-PRDT_QTY"(생산량), "ITEM-PRDT-LINE-USE_HR"(사용시간)
                     , '생산' AS HEADER2_NM, ORG_NAME AS HEADER3_NM
                     , CASE WHEN ACCT_CD = 'PRDT_QTY' THEN LINE_DEPT_NAME
                            ELSE                           LINE_DEPT_NAME || '-' || ACCT_NM
                       END                                                          AS HEADER4_NM
                     , CASE WHEN ACCT_CD = 'PRDT_QTY' THEN 1 ELSE 0 END             AS COL_VISIBLE
                     , CASE WHEN ACCT_CD = 'PRDT_QTY' THEN 70 ELSE 0 END            AS COL_WIDTH
                     , 'Float' AS COL_TYPE
                     , CASE WHEN ACCT_CD = 'PRDT_QTY' THEN ',0' ELSE ',0.00' END    AS COL_FORMAT
                     , 'Right' AS COL_ALIGN
                     , CASE WHEN ACCT_CD = 'PRDT_QTY' THEN 1 ELSE 0 END             AS COL_CAN_EDIT
                     , 130000 + ORG_SEQ * 1000 + LINE_DEPT_SEQ * 10 + ACCT_SEQ      AS COL_SEQ
                     , ORG_CODE, ORG_NAME, LINE_DEPT_CODE, LINE_DEPT_NAME, VESSEL_LIST, ITEM_CODE_LIST
                  FROM (
                            SELECT DE.ORG_CODE, MAX(REPLACE(DF.ORG_NAME, '공장 생산', '')) AS ORG_NAME
                                 , DE.LINE_DEPT_CODE, NVL(DE.LINE_DEPT_NAME, NVL(DI.LINE_DEPT_NAME, DE.LINE_DEPT_CODE)) AS LINE_DEPT_NAME
                                 , DE.LIQUOR_CODE
                                 , DH.ACCT_CD, DH.ACCT_NM, DH.ACCT_SEQ
                                 , ',' || LISTAGG(DE.VESSEL_CODE, ',') || ',' AS VESSEL_LIST
                                 , DENSE_RANK() OVER (ORDER BY DE.ORG_CODE)                                AS ORG_SEQ
                                 , DENSE_RANK() OVER (PARTITION BY DE.ORG_CODE ORDER BY DE.LINE_DEPT_CODE) AS LINE_DEPT_SEQ
                                 , MAX(DE.ITEM_CODE_LIST)                                                  AS ITEM_CODE_LIST

                              FROM (    -- 시뮬레이션 결과 + 생산변수에 정의된 공장/라인/제품 : 모제품매핑 필요
                                        SELECT ORG_CODE, LINE_DEPT_CODE, LINE_DEPT_NAME, LIQUOR_CODE, VESSEL_CODE
                                             , ',' || LISTAGG(ITEM_CODE, ',') || ',' AS ITEM_CODE_LIST -- 생산실적/계획이 존재하거나 단위생산량이 존재하는 공장/라인/제품 리스트만 고르기 위한 제품 리스트
                                          FROM (
                                                    SELECT DISTINCT DA.ORG_CODE, DA.LINE_DEPT_CODE, DA.LINE_DEPT_NAME, DD.LIQUOR_CODE, DD.VESSEL_CODE, DA.ITEM_CODE
                                                      FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_RESULT_F DA
                                                      JOIN EDW.W_CM_TB_FG_ITEM_M                 DD
                                                        ON DD.ITEM_CODE = DA.ITEM_CODE
                                                     WHERE 1 = 1
                                                       AND DA.VER_CD         = #{verCd, jdbcType=VARCHAR}
                                                       AND DA.LIQUOR_CODE    = #{liquorCode, jdbcType=VARCHAR}
                                                       AND DA.ORG_CODE       != '-'
                                                       AND DA.LINE_DEPT_CODE != '-'
                                                       AND NVL(DA.PRDT_QTY, 0) != 0
                                                     UNION
                                                    SELECT DISTINCT DC.ORG_CODE, DC.LINE_DEPT_CODE, DC.LINE_DEPT_NAME, DD.LIQUOR_CODE, DD.VESSEL_CODE, DC.ITEM_CODE
                                                      FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_M DB
                                                      JOIN SCMU.W_SOP_TB_PRDT_VAR_DTL_M   DC
                                                        ON DC.PRDT_VAR_VER_CD = DB.PRDT_VAR_VER_CD
                                                      JOIN EDW.W_CM_TB_FG_ITEM_M          DD
                                                        ON DD.ITEM_CODE = DC.ITEM_CODE
                                                     WHERE 1 = 1
                                                       AND DB.VER_CD               = #{verCd, jdbcType=VARCHAR}
                                                       AND NVL(DC.QTY_PER_HOUR, 0) > 0
                                                       AND DD.LIQUOR_CODE          = #{liquorCode, jdbcType=VARCHAR}
                                               )
                                         WHERE 1 = 1
                                         GROUP BY ORG_CODE, LINE_DEPT_CODE, LINE_DEPT_NAME, LIQUOR_CODE, VESSEL_CODE
                                   )                          DE
                         LEFT JOIN EDW.W_CM_TB_ORGANIZATION_M DF
                                ON DF.ORG_CODE = DE.ORG_CODE
                        CROSS JOIN (    -- DH. 생산량/사용시간 리스트
                                        SELECT 'PRDT_QTY' AS ACCT_CD, '생산량'   AS ACCT_NM, 1 AS ACCT_SEQ FROM DUAL UNION ALL
                                        SELECT 'USE_HR'   AS ACCT_CD, '사용시간' AS ACCT_NM, 2 AS ACCT_SEQ FROM DUAL
                                   )                          DH
                         LEFT JOIN (    -- DI. 공장/라인의 명칭 : 간혹 생산변수에 정의되지 않은 라인의 명칭 때문에
                                        SELECT VER_CD, ORG_CODE, LINE_DEPT_CODE
                                             , MAX(LINE_DEPT_NAME) AS LINE_DEPT_NAME
                                          FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_PRDT_F
                                         WHERE 1 = 1
                                           AND VER_CD = #{verCd, jdbcType=VARCHAR}
                                         GROUP BY VER_CD, ORG_CODE, LINE_DEPT_CODE
                                   )                          DI
                                ON DI.ORG_CODE       = DE.ORG_CODE
                               AND DI.LINE_DEPT_CODE = DE.LINE_DEPT_CODE
                             WHERE 1 = 1
                               AND DE.LIQUOR_CODE = #{liquorCode, jdbcType=VARCHAR}
                             GROUP BY DE.ORG_CODE, DE.LINE_DEPT_CODE, NVL(DE.LINE_DEPT_NAME, NVL(DI.LINE_DEPT_NAME, DE.LINE_DEPT_CODE)), DE.LIQUOR_CODE, DH.ACCT_CD, DH.ACCT_NM, DH.ACCT_SEQ
                       )
                 WHERE 1 = 1
                 UNION ALL
                SELECT 'ITEM-STOCK_QTY' AS GUBUN, '재고' AS HEADER2_NM, NULL AS HEADER3_NM, NULL AS HEADER4_NM
                     , 1 AS COL_VISIBLE, 70 AS COL_WIDTH, 'Float' AS COL_TYPE, ',0' AS COL_FORMAT, 'Right' AS COL_ALIGN, 0 AS COL_CAN_EDIT, 141000 AS COL_SEQ
                     , '-' AS ORG_CODE, '-' AS ORG_NAME, '-' AS LINE_DEPT_CODE, '-' AS LINE_DEPT_NAME, '!ALL' AS VESSEL_LIST, '!ALL' AS ITEM_CODE_LIST
                  FROM DUAL
                 UNION ALL
                SELECT 'ITEM-STOCK_DCNT' AS GUBUN, '재고일수' AS HEADER2_NM, NULL AS HEADER3_NM, NULL AS HEADER4_NM
                     , 1 AS COL_VISIBLE, 70 AS COL_WIDTH, 'Float' AS COL_TYPE, ',0.0' AS COL_FORMAT, 'Right' AS COL_ALIGN, 0 AS COL_CAN_EDIT, 142000 AS COL_SEQ
                     , '-' AS ORG_CODE, '-' AS ORG_NAME, '-' AS LINE_DEPT_CODE, '-' AS LINE_DEPT_NAME, '!ALL' AS VESSEL_LIST, '!ALL' AS ITEM_CODE_LIST
                  FROM DUAL
           )                                    D
        ON 1 = 1
       AND (
                (D.VESSEL_LIST = '!ALL')
                OR
                (INSTR(D.VESSEL_LIST, ',' || C.VESSEL_CODE || ',') > 0)
           )
       AND (
                (D.ITEM_CODE_LIST = '!ALL')
                OR
                (INSTR(D.ITEM_CODE_LIST, ',' || C.ITEM_CODE || ',') > 0)
           )
     WHERE 1 = 1
       AND A.VER_CD      = #{verCd, jdbcType=VARCHAR}
       AND (
                (NVL(#{vesselCode, jdbcType=VARCHAR}, '!ALL') = '!ALL' AND 1 = 1)
                OR
                (#{vesselCode, jdbcType=VARCHAR} = C.VESSEL_CODE)
           )
       AND (    -- 읽기전용여부
                (NVL(#{readOnlyYn, jdbcType=VARCHAR}, 'Y') = 'Y' AND D.COL_GUBUN NOT IN ('ITEM-SALE_AVG_QTY', 'ITEM-PRDT-LINE-PRDT_QTY', 'ITEM-PRDT-LINE-USE_HR'))
                OR
                (NVL(#{readOnlyYn, jdbcType=VARCHAR}, 'Y') = 'N' AND 1 = 1)
           )
     --ORDER BY DECODE(C.DOM_EXP_CODE, '1', -1, 1), C.BRAND_SORT_ORDER, C.BRAND_NAME, C.DESCRIPTION, B.ITEM_CODE, D.COL_SEQ

     UNION ALL
    -- 2. 공장/라인의 가용/사용시간 리스트
    SELECT A.VER_CD, D.LIQUOR_CODE
         , D.COL_GUBUN                                      -- COL구분 : CHECK_PRDT_HR-LINE-AVL_HR, CHECK_PRDT_HR-LINE-USE_HR
         , D.COL_VISIBLE, D.COL_WIDTH, D.COL_TYPE, D.COL_FORMAT, D.COL_ALIGN, D.COL_CAN_EDIT, D.COL_SEQ
         
         , D.HEADER1_NM                 AS HEADER1_NM       -- 헤더 1행 표현 : 제품명칭 리스트, 생산시간 체크
         , 1                            AS HEADER1_ROWSPAN  -- 헤더 1행 RowSpan : 1로 고정
         , COUNT(1) OVER (PARTITION BY D.HEADER1_NM)
                                        AS HEADER1_COLSPAN  -- 헤더 1행 ColSpan : 제품명칭은 판매(1)+일평균판매량(1)+생산량합계(1)+공장/라인리스트(?)*생산량/사용시간(2)+재고(1)+재고일수(1). 생산시간은 공장/라인리스트(?) * 가용시간/사용시간(2)
         
         , CASE WHEN ROW_NUMBER() OVER (PARTITION BY D.HEADER1_NM || D.HEADER2_NM ORDER BY D.COL_SEQ) = 1 THEN D.HEADER2_NM
                ELSE TO_CHAR(NULL)
           END                          AS HEADER2_NM       -- 헤더 2행 : 제품명칭 밑에 판매, 생산, 재고, 재고일수. 생산시간 밑에 공장명칭
         , 1                            AS HEADER2_ROWSPAN  -- 헤더 2행 RowSpan : 제품-판매는 3으로 고정. 제품-생산은 1로 고정. 제품-재고/재고일수는 3으로 고정. 생산시간-공장은 1로 고정
         , CASE WHEN ROW_NUMBER() OVER (PARTITION BY D.HEADER1_NM || D.HEADER2_NM ORDER BY D.COL_SEQ) = 1 THEN COUNT(1) OVER (PARTITION BY D.HEADER1_NM || D.HEADER2_NM)
                ELSE 1
           END                          AS HEADER2_COLSPAN  -- 헤더 2행 ColSpan : 제품-판매는 1로 고정. 제품-생산은 생산량합계(1)+공장/라인리스트(?)*생산량/사용시간(2). 제품-재고/재고일수는 1로 고정. 생산시간-공장은 라인리스트(?) * 가용시간/사용시간(2)
         
         , CASE WHEN ROW_NUMBER() OVER (PARTITION BY D.HEADER1_NM || D.HEADER2_NM || D.HEADER3_NM ORDER BY D.COL_SEQ) = 1 THEN D.HEADER3_NM
                ELSE TO_CHAR(NULL)
           END                          AS HEADER3_NM       -- 헤더 3행 : 제품-생산 밑에 공장명칭. 생산시간-공장 밑에 라인명칭
         , 1                            AS HEADER3_ROWSPAN  -- 헤더 3행 RowSpan : 1은 표현 제외. 제품-생산-생산량합계는 2로 고정
         , CASE WHEN ROW_NUMBER() OVER (PARTITION BY D.HEADER1_NM || D.HEADER2_NM || D.HEADER3_NM ORDER BY D.COL_SEQ) = 1 THEN COUNT(1) OVER (PARTITION BY D.HEADER1_NM || D.HEADER2_NM || D.HEADER3_NM)
                ELSE 1
           END                          AS HEADER3_COLSPAN  -- 헤더 3행 ColSpan : 1은 표현 제외. 제품-생산-공장은 라인리스트(?)*생산량/사용시간(2). 생산시간-공장-라인은 2로 고정(가용시간/사용시간)
         
         , D.HEADER4_NM                 AS HEADER4_NM       -- 헤더 4행 : 제품-생산-공장 밑에 라인명칭(생산량/사용시간). 생산시간-공장-라인 밑에 가용시간, 사용시간
         , 1                            AS HEADER4_ROWSPAN  -- 헤더 4행 RowSpan : 모두 1로 고정(즉, 표현 불필요)
         , 1                            AS HEADER4_COLSPAN  -- 헤더 4행 ColSpan : 모두 1로 고정(즉, 표현 불필요)
         
         , '-' AS ITEM_CODE, NULL AS ITEM_NAME
         , NULL AS BRAND_CODE, NULL AS BRAND_NAME, NULL AS BRAND_SORT_ORDER, NULL AS VESSEL_CODE, NULL AS VESSEL_SORT, NULL AS VESSEL_SORT_ORDER, NULL AS USAGE_CODE, NULL AS USAGE_NAME, NULL AS USAGE_SORT_ORDER, NULL AS VOLUME_VALUE, NULL AS DOM_EXP_CODE, NULL AS DOM_EXP_FLAG
         , D.ORG_CODE, D.ORG_NAME, D.LINE_DEPT_CODE, D.LINE_DEPT_NAME
         , 'COL_' || (20000 + ROW_NUMBER() OVER (PARTITION BY A.VER_CD ORDER BY D.COL_SEQ)) AS COL_ID
         
      FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_M       A
      JOIN (    -- D. 가용생산시간 - 공장/라인 리스트 * 가용시간/사용시간 : 시뮬레이션 결과 + 생산변수(단위 생산량 존재)
                SELECT 'CHECK_PRDT_HR-LINE-' || ACCT_CD                                 AS COL_GUBUN -- "ITEM-PRDT-LINE-PRDT_QTY"(생산량), "ITEM-PRDT-LINE-USE_HR"(사용시간)
                     , '가용 생산시간 체크' AS HEADER1_NM, ORG_NAME AS HEADER2_NM, LINE_DEPT_NAME AS HEADER3_NM, ACCT_NM AS HEADER4_NM
                     , 1 AS COL_VISIBLE, 70 AS COL_WIDTH, 'Float' AS COL_TYPE, ',0.0' AS COL_FORMAT, 'Right' AS COL_ALIGN, 0 AS COL_CAN_EDIT
                     , 200000 + ORG_SEQ * 1000 + LINE_DEPT_SEQ * 10 + ACCT_SEQ      AS COL_SEQ
                     , ORG_CODE, ORG_NAME, LINE_DEPT_CODE, LINE_DEPT_NAME, LIQUOR_CODE
                  FROM (
                            SELECT DE.ORG_CODE, MAX(REPLACE(DF.ORG_NAME, '공장 생산', '')) AS ORG_NAME
                                 , DE.LINE_DEPT_CODE, NVL(DE.LINE_DEPT_NAME, NVL(DI.LINE_DEPT_NAME, DE.LINE_DEPT_CODE)) AS LINE_DEPT_NAME
                                 , DE.LIQUOR_CODE
                                 , DH.ACCT_CD, DH.ACCT_NM, DH.ACCT_SEQ
                                 , ',' || LISTAGG(DE.VESSEL_CODE, ',') || ',' AS VESSEL_LIST
                                 , DENSE_RANK() OVER (ORDER BY DE.ORG_CODE)                                AS ORG_SEQ
                                 , DENSE_RANK() OVER (PARTITION BY DE.ORG_CODE ORDER BY DE.LINE_DEPT_CODE) AS LINE_DEPT_SEQ
                                 --, DE.ITEM_CODE, DG.LIQUOR_CODE
                              FROM (    -- 시뮬레이션 결과 + 생산변수에 정의된 공장/라인/제품 : 모제품매핑 필요
                                        SELECT DISTINCT DA.ORG_CODE, DA.LINE_DEPT_CODE, DA.LINE_DEPT_NAME, DD.LIQUOR_CODE, DD.VESSEL_CODE
                                          FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_RESULT_F DA
                                          JOIN EDW.W_CM_TB_FG_ITEM_M                 DD
                                            ON DD.ITEM_CODE = DA.ITEM_CODE
                                         WHERE 1 = 1
                                           AND DA.VER_CD         = #{verCd, jdbcType=VARCHAR}
                                           AND DA.LIQUOR_CODE    = #{liquorCode, jdbcType=VARCHAR}
                                           AND DA.ORG_CODE       != '-'
                                           AND DA.LINE_DEPT_CODE != '-'
                                           AND (NVL(DA.PRDT_QTY, 0) != 0 OR NVL(DA.STOCK_QTY, 0) != 0)
                                         UNION
                                        SELECT DISTINCT DC.ORG_CODE, DC.LINE_DEPT_CODE, DC.LINE_DEPT_NAME, DD.LIQUOR_CODE, DD.VESSEL_CODE
                                          FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_M DB
                                          JOIN SCMU.W_SOP_TB_PRDT_VAR_DTL_M   DC
                                            ON DC.PRDT_VAR_VER_CD = DB.PRDT_VAR_VER_CD
                                          JOIN EDW.W_CM_TB_FG_ITEM_M          DD
                                            ON DD.ITEM_CODE = DC.ITEM_CODE
                                         WHERE 1 = 1
                                           AND DB.VER_CD               = #{verCd, jdbcType=VARCHAR}
                                           AND NVL(DC.QTY_PER_HOUR, 0) > 0
                                           AND DD.LIQUOR_CODE          = #{liquorCode, jdbcType=VARCHAR}
                                   )                          DE
                         LEFT JOIN EDW.W_CM_TB_ORGANIZATION_M DF
                                ON DF.ORG_CODE = DE.ORG_CODE
                        CROSS JOIN (    -- DH. 생산량/사용시간 리스트
                                        SELECT 'AVL_HR' AS ACCT_CD, '가용시간' AS ACCT_NM, 1 AS ACCT_SEQ FROM DUAL UNION ALL
                                        SELECT 'USE_HR' AS ACCT_CD, '사용시간' AS ACCT_NM, 2 AS ACCT_SEQ FROM DUAL
                                   )                          DH
                         LEFT JOIN (    -- DI. 공장/라인의 명칭 : 간혹 생산변수에 정의되지 않은 라인의 명칭 때문에
                                        SELECT VER_CD, ORG_CODE, LINE_DEPT_CODE
                                             , MAX(LINE_DEPT_NAME) AS LINE_DEPT_NAME
                                          FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_PRDT_F
                                         WHERE 1 = 1
                                           AND VER_CD = #{verCd, jdbcType=VARCHAR}
                                         GROUP BY VER_CD, ORG_CODE, LINE_DEPT_CODE
                                   )                          DI
                                ON DI.ORG_CODE       = DE.ORG_CODE
                               AND DI.LINE_DEPT_CODE = DE.LINE_DEPT_CODE
                             WHERE 1 = 1
                               AND DE.LIQUOR_CODE = #{liquorCode, jdbcType=VARCHAR}
                               AND (
                                        (NVL(#{vesselCode, jdbcType=VARCHAR}, '!ALL') = '!ALL' AND 1 = 1)
                                        OR
                                        (#{vesselCode, jdbcType=VARCHAR} = DE.VESSEL_CODE)
                                   )
                             GROUP BY DE.ORG_CODE, DE.LINE_DEPT_CODE, NVL(DE.LINE_DEPT_NAME, NVL(DI.LINE_DEPT_NAME, DE.LINE_DEPT_CODE)), DE.LIQUOR_CODE, DH.ACCT_CD, DH.ACCT_NM, DH.ACCT_SEQ
                       )
                 WHERE 1 = 1
           )                                    D
        ON 1 = 1
     WHERE 1 = 1
       AND A.VER_CD      = #{verCd, jdbcType=VARCHAR}

     ORDER BY VER_CD, COL_ID
    </select>
    
    <!-- 결과설정의 그리드 바디 조회 : 버전의 기간 리스트와 헤더의 조합 -->
    <select id="searchResultBody" parameterType="map" resultType="map">
WITH RESULT_TBL AS (
    -- E. 판매량, 월별판매량, 공장/라인의 생산량/사용시간, 재고량, 공장/라인의 가용시간 : 속도향상을 위해서 WITH절로 분리
    SELECT EV.VER_CD, EV.PERIOD_TYPE, EV.PERIOD_CODE
         , EV.PERIOD_FR_YYYYMMDD, EV.PERIOD_TO_YYYYMMDD
         , EZ.ITEM_CODE, EZ.ORG_CODE, EZ.LINE_DEPT_CODE
         , SUM(NVL(EZ.SALE_QTY, 0))     AS SALE_QTY
         , MAX(NVL(EZ.MM_SALE_QTY, 0))  AS MM_SALE_QTY
         , SUM(NVL(EZ.USE_HR, 0))       AS USE_HR
         , SUM(NVL(EZ.PRDT_QTY, 0))     AS PRDT_QTY
         , SUM(CASE WHEN EZ.PERIOD_TYPE = 'YYYYMMDD' AND EZ.PERIOD_CODE = EV.PERIOD_TO_YYYYMMDD THEN NVL(EZ.STOCK_QTY, 0) ELSE 0 END) AS STOCK_QTY
         --, SUM(NVL(EZ.STOCK_QTY, 0))    AS STOCK_QTY
         , SUM(NVL(EZ.AVL_HR, 0))       AS AVL_HR
      FROM (
                SELECT EW.VER_CD, EY.PERIOD_TYPE
                     , CASE WHEN EY.PERIOD_TYPE = 'YYYYMM'   THEN EX.YYYYMM
                            WHEN EY.PERIOD_TYPE = 'YYYYWW'   THEN EX.SCM_YYYYWW
                            WHEN EY.PERIOD_TYPE = 'YYYYMMDD' THEN EX.YYYYMMDD
                       END                          AS PERIOD_CODE
                     , MIN(EX.YYYYMMDD) AS PERIOD_FR_YYYYMMDD
                     , MAX(EX.YYYYMMDD) AS PERIOD_TO_YYYYMMDD
                  FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_M   EW
                  JOIN SCMU.W_SOP_VW_CALENDAR_M         EX
                    ON EX.YYYYMMDD BETWEEN EW.VER_FR_DT AND EW.VER_TO_DT
            CROSS JOIN (
                            SELECT 'YYYYMM'   AS PERIOD_TYPE, 1 AS SEQ FROM DUAL UNION ALL
                            SELECT 'YYYYWW'   AS PERIOD_TYPE, 2 AS SEQ FROM DUAL UNION ALL
                            SELECT 'YYYYMMDD' AS PERIOD_TYPE, 3 AS SEQ FROM DUAL
                       )                        EY
                 WHERE 1 = 1
                   AND EW.VER_CD = #{verCd, jdbcType=VARCHAR}
                 GROUP BY EW.VER_CD, EY.PERIOD_TYPE--, EZ.ITEM_CODE, EZ.ORG_CODE, EZ.LINE_DEPT_CODE
                        , CASE WHEN EY.PERIOD_TYPE = 'YYYYMM'   THEN EX.YYYYMM
                               WHEN EY.PERIOD_TYPE = 'YYYYWW'   THEN EX.SCM_YYYYWW
                               WHEN EY.PERIOD_TYPE = 'YYYYMMDD' THEN EX.YYYYMMDD
                          END
           )                                    EV
      JOIN (
                SELECT EZ.VER_CD, EZ.PERIOD_CODE, EZ.PERIOD_TYPE
                     , EZ.ITEM_CODE, EZ.ORG_CODE, EZ.LINE_DEPT_CODE
                     , MAX(NVL(EZ.SALE_QTY, 0)) AS SALE_QTY, MAX(NVL(EZ.MM_SALE_QTY, 0)) AS MM_SALE_QTY, MAX(NVL(EZ.USE_HR, 0)) AS USE_HR, MAX(NVL(EZ.PRDT_QTY, 0)) AS PRDT_QTY, MAX(NVL(EZ.STOCK_QTY, 0)) AS STOCK_QTY, MAX(NVL(EZ.AVL_HR, 0)) AS AVL_HR
                  FROM (
                            -- EA. 일자별 판매량 : 공장/라인='-'
                            SELECT EA.VER_CD, EA.LIQUOR_CODE, EA.PERIOD_YYYYMMDD AS PERIOD_CODE, 'YYYYMMDD' AS PERIOD_TYPE
                                 , EI.ITEM_CODE, '-' AS ORG_CODE, '-' AS LINE_DEPT_CODE
                                 , NVL(EA.SALE_QTY, 0) AS SALE_QTY
                                 , 0 AS MM_SALE_QTY, 0 AS USE_HR, 0 AS PRDT_QTY, 0 AS STOCK_QTY, 0 AS AVL_HR
                              FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_SALE_F      EA
                              JOIN EDW.W_CM_TB_FG_ITEM_M                    EI
                                ON EI.ITEM_CODE = EA.ITEM_CODE
                             WHERE 1 = 1
                               AND EA.VER_CD      = #{verCd, jdbcType=VARCHAR}
                               AND EA.ITEM_MAP_YN = 'Y' -- 모제품매핑만 사용
                               AND EA.LIQUOR_CODE = #{liquorCode, jdbcType=VARCHAR}
                               AND (
                                        (NVL(#{vesselCode, jdbcType=VARCHAR}, '!ALL') = '!ALL' AND 1 = 1)
                                        OR
                                        (#{vesselCode, jdbcType=VARCHAR} = EI.VESSEL_CODE)
                                   )
                               AND NVL(EA.SALE_QTY, 0) != 0
                             UNION ALL
                            -- EB. 제품/공장/라인의 사용시간/생산량. 제품의 재고량(공장/라인='-'). 단, 실적 생산량은 제품/공장으로만 존재(라인='-')
                            SELECT EB.VER_CD, EB.LIQUOR_CODE, EB.PERIOD_YYYYMMDD AS PERIOD_CODE, 'YYYYMMDD' AS PERIOD_TYPE
                                 , EI.ITEM_CODE, EB.ORG_CODE, EB.LINE_DEPT_CODE
                                 , 0 AS SALE_QTY, 0 AS MM_SALE_QTY, SUM(NVL(EB.USE_HR, 0)) AS USE_HR, SUM(NVL(EB.PRDT_QTY, 0)) AS PRDT_QTY, SUM(NVL(EB.STOCK_QTY, 0)) AS STOCK_QTY, 0 AS AVL_HR
                              FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_RESULT_F    EB
                              JOIN EDW.W_CM_TB_FG_ITEM_M                    EI
                                ON EI.ITEM_CODE = EB.ITEM_CODE
                             WHERE 1 = 1
                               AND EB.VER_CD      = #{verCd, jdbcType=VARCHAR}
                               AND EB.LIQUOR_CODE = #{liquorCode, jdbcType=VARCHAR}
                               AND (
                                        (NVL(#{vesselCode, jdbcType=VARCHAR}, '!ALL') = '!ALL' AND 1 = 1)
                                        OR
                                        (#{vesselCode, jdbcType=VARCHAR} = EI.VESSEL_CODE)
                                   )
                               AND (NVL(EB.USE_HR, 0) != 0 OR NVL(EB.PRDT_QTY, 0) != 0 OR NVL(EB.STOCK_QTY, 0) != 0)
                             GROUP BY EB.VER_CD, EB.LIQUOR_CODE, EB.PERIOD_YYYYMMDD, EI.ITEM_CODE, EB.ORG_CODE, EB.LINE_DEPT_CODE
                             UNION ALL
                            -- EC. 공장/라인의 가용시간 : 제품='-'
                            SELECT EC.VER_CD, EC.LIQUOR_CODE, EC.PERIOD_CODE, 'YYYYMMDD' AS PERIOD_TYPE
                                 , '-' AS ITEM_CODE, EC.ORG_CODE, EC.LINE_DEPT_CODE
                                 , 0 AS SALE_QTY, 0 AS MM_SALE_QTY, 0 AS USE_HR, 0 AS PRDT_QTY, 0 AS STOCK_QTY, SUM(NVL(EC.AVL_HR, 0)) AS AVL_HR
                              FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_PRDT_F      EC
                             WHERE 1 = 1
                               AND EC.VER_CD      = #{verCd, jdbcType=VARCHAR}
                               AND EC.LIQUOR_CODE = #{liquorCode, jdbcType=VARCHAR}
                               AND EC.PERIOD_TYPE = 'YYYYMMDD'
                               AND NVL(EC.AVL_HR, 0) != 0
                             GROUP BY EC.VER_CD, EC.LIQUOR_CODE, EC.PERIOD_CODE, EC.ORG_CODE, EC.LINE_DEPT_CODE
                             UNION ALL
                            -- ED. 월별 판매량 : 공장/라인='-'
                            SELECT ED.VER_CD, ED.LIQUOR_CODE, SUBSTR(ED.PERIOD_YYYYMMDD, 1, 6) AS PERIOD_CODE, 'YYYYMM' AS PERIOD_TYPE
                                 , EI.ITEM_CODE, '-' AS ORG_CODE, '-' AS LINE_DEPT_CODE
                                 , 0 AS SALE_QTY
                                 , SUM(NVL(ED.SALE_QTY, 0)) AS MM_SALE_QTY
                                 , 0 AS USE_HR, 0 AS PRDT_QTY, 0 AS STOCK_QTY, 0 AS AVL_HR
                              FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_SALE_F      ED
                              JOIN EDW.W_CM_TB_FG_ITEM_M                    EI
                                ON EI.ITEM_CODE = ED.ITEM_CODE
                             WHERE 1 = 1
                               AND ED.VER_CD      = #{verCd, jdbcType=VARCHAR}
                               AND ED.ITEM_MAP_YN = 'Y' -- 모제품매핑만 사용
                               AND ED.LIQUOR_CODE = #{liquorCode, jdbcType=VARCHAR}
                               AND (
                                        (NVL(#{vesselCode, jdbcType=VARCHAR}, '!ALL') = '!ALL' AND 1 = 1)
                                        OR
                                        (#{vesselCode, jdbcType=VARCHAR} = EI.VESSEL_CODE)
                                   )
                               AND NVL(ED.SALE_QTY, 0) != 0
                             GROUP BY ED.VER_CD, ED.LIQUOR_CODE, SUBSTR(ED.PERIOD_YYYYMMDD, 1, 6), EI.ITEM_CODE
                       ) EZ
                 GROUP BY EZ.VER_CD, EZ.PERIOD_CODE, EZ.PERIOD_TYPE, EZ.ITEM_CODE, EZ.ORG_CODE, EZ.LINE_DEPT_CODE
           )                            EZ
        ON EZ.VER_CD = EV.VER_CD
       AND (    -- 월별 판매량을 월별로 일자/주간/월에 동일하게 표현하기 위해서, 이렇게 복잡하게 쿼리 만듬
                (EZ.PERIOD_TYPE = 'YYYYMMDD' AND EZ.PERIOD_CODE BETWEEN EV.PERIOD_FR_YYYYMMDD AND EV.PERIOD_TO_YYYYMMDD)    -- 일자 데이터의 해당 구간에 맞게 합산
                OR
                (EZ.PERIOD_TYPE = 'YYYYMM'   AND EZ.PERIOD_CODE = SUBSTR(EV.PERIOD_FR_YYYYMMDD, 1, 6))                      -- 월간 데이터(월별 판매량)은 해당 구간의 시작일 기준
           )
     WHERE 1 = 1
     GROUP BY EV.VER_CD, EV.PERIOD_TYPE, EV.PERIOD_CODE, EV.PERIOD_FR_YYYYMMDD, EV.PERIOD_TO_YYYYMMDD, EZ.ITEM_CODE, EZ.ORG_CODE, EZ.LINE_DEPT_CODE
)
    SELECT /* com.hitejinro.snop.work.dao.M02020DaoMapper.searchResultBody */
           A.VER_CD
         , A.STD_YYYYMMDD       -- 기준일자(실적일자)
         , B.LIQUOR_CODE, B.LIQUOR_DESC, D.PERIOD_TYPE, D.PERIOD_CODE, D.PERIOD_NAME
        <![CDATA[
         , MAX(
                CASE WHEN D.PERIOD_TYPE = 'YYYYMMDD' AND D.PERIOD_CODE <= A.STD_YYYYMMDD THEN D.PERIOD_TYPE || '_ACTUAL'
                     WHEN D.PERIOD_TYPE = 'YYYYMMDD' AND D.PERIOD_CODE >  A.STD_YYYYMMDD THEN D.PERIOD_TYPE || '_PLAN'
                     ELSE                                                                     D.PERIOD_TYPE
                END
              ) AS "Def"    -- 트리그리드의 행별 속성 설정 : YYYYMM, YYYYWW, YYYYMMDD
        ]]>
         , MAX(
                CASE WHEN D.PERIOD_TYPE = 'YYYYMM'   THEN ''
                     WHEN D.PERIOD_TYPE = 'YYYYWW'   THEN '    '
                     WHEN D.PERIOD_TYPE = 'YYYYMMDD' THEN '        '
                     ELSE                                 ''
                END
                || D.PERIOD_NAME
              )
                AS PERIOD_DESC  -- 기간유형에 따라서, 들여쓰기 처리
         , D.BUSINESS_DAY_FLAG, D.PERIOD_FR_YYYYMMDD, D.PERIOD_TO_YYYYMMDD, D.PERIOD_TYPE_SEQ
         , MAX(D.CALENDAR_WORK_CNT) AS CALENDAR_WORK_CNT, MAX(D.WORK_CNT) AS WORK_CNT
        <![CDATA[
         , MAX(
                CASE WHEN D.PERIOD_TYPE = 'YYYYMMDD' AND D.PERIOD_CODE <= A.STD_YYYYMMDD THEN '실적'
                     WHEN D.PERIOD_TYPE = 'YYYYMMDD' AND D.PERIOD_CODE >  A.STD_YYYYMMDD THEN '계획'
                END
              ) AS ACTUAL_PLAN_GUBUN
        ]]>
         
         /* COL_GUBUN : ITEM-SALE_QTY, ITEM-SALE_AVG_QTY, ITEM-PRDT-TOTAL_PRDT_QTY, ITEM-PRDT-LINE-PRDT_QTY, ITEM-PRDT-LINE-USE_HR, ..., ITEM-STOCK_QTY, ITEM-STOCK_DCNT
                        CHECK_PRDT_HR-LINE-AVL_HR, CHECK_PRDT_HR-LINE-USE_HR
         , SUM(CASE WHEN E.ITEM_CODE = '10310971' THEN NVL(E.SALE_QTY, 0) ELSE 0 END)                                                                       AS COL_10001 -- COL_GUBUN=ITEM-SALE_QTY
         , SUM(CASE WHEN E.ITEM_CODE = '10310971' THEN NVL(E.MM_SALE_QTY, 0) ELSE 0 END) / DECODE(MAX(F.YYYYMM_WORK_CNT), 0, NULL, MAX(F.YYYYMM_WORK_CNT))  AS COL_10002 -- COL_GUBUN=ITEM-SALE_AVG_QTY
         , SUM(CASE WHEN E.ITEM_CODE = '10310971' THEN NVL(E.PRDT_QTY, 0) ELSE 0 END)                                                                       AS COL_10003 -- COL_GUBUN=ITEM-PRDT-TOTAL_PRDT_QTY
         , SUM(CASE WHEN E.ITEM_CODE = '10310971' AND E.ORG_CODE = 'MH1' AND E.LINE_DEPT_CODE = 'BTL1' THEN NVL(E.PRDT_QTY, 0) ELSE 0 END)                  AS COL_10004 -- COL_GUBUN=ITEM-PRDT-LINE-PRDT_QTY
         , SUM(CASE WHEN E.ITEM_CODE = '10310971' AND E.ORG_CODE = 'MH1' AND E.LINE_DEPT_CODE = 'BTL1' THEN NVL(E.USE_HR, 0) ELSE 0 END)                    AS COL_10005 -- COL_GUBUN=ITEM-PRDT-LINE-USE_HR
         --, ...
         , SUM(CASE WHEN E.ITEM_CODE = '10310971' THEN NVL(E.STOCK_QTY, 0) ELSE 0 END)                                                                      AS COL_10016 -- COL_GUBUN=ITEM-STOCK_QTY
         , CASE WHEN SUM(CASE WHEN E.ITEM_CODE = '10310971' THEN NVL(E.MM_SALE_QTY, 0) ELSE 0 END) = 0 THEN NULL
                ELSE SUM(CASE WHEN E.ITEM_CODE = '10310971' THEN NVL(E.STOCK_QTY, 0) ELSE 0 END) / SUM(CASE WHEN E.ITEM_CODE = '10310971' THEN NVL(E.MM_SALE_QTY, 0) ELSE 0 END) * MAX(F.YYYYMM_WORK_CNT)
           END                                                                                                                                              AS COL_10017 -- COL_GUBUN=ITEM-STOCK_DCNT
         --, ...
         , MAX(CASE WHEN E.ITEM_CODE = '-' AND E.ORG_CODE = 'MH1' AND E.LINE_DEPT_CODE = 'BTL1' THEN NVL(E.AVL_HR, 0) ELSE 0 END)                           AS COL_20001 -- COL_GUBUN=CHECK_PRDT_HR-LINE-AVL_HR
         , SUM(CASE WHEN                       E.ORG_CODE = 'MH1' AND E.LINE_DEPT_CODE = 'BTL1' THEN NVL(E.USE_HR, 0) ELSE 0 END)                           AS COL_20002 -- COL_GUBUN=CHECK_PRDT_HR-LINE-USE_HR
         --, ...
         */
         
        <if test="TREEGRID_HEADER != '' and TREEGRID_HEADER != null">
            <foreach open="" collection="TREEGRID_HEADER" index="index" item="item" separator="" close="">
                <choose>
                    <when test="item.COL_GUBUN != null and item.COL_GUBUN eq 'ITEM-SALE_QTY'.toString()">
         , SUM(CASE WHEN E.ITEM_CODE = #{item.ITEM_CODE, jdbcType=VARCHAR} THEN NVL(E.SALE_QTY, 0) ELSE 0 END)                                                                       AS ${item.COL_ID}
                    </when>
                    <when test="item.COL_GUBUN != null and item.COL_GUBUN eq 'ITEM-SALE_AVG_QTY'.toString()">
         , SUM(CASE WHEN E.ITEM_CODE = #{item.ITEM_CODE, jdbcType=VARCHAR} THEN NVL(E.MM_SALE_QTY, 0) ELSE 0 END) / DECODE(MAX(F.YYYYMM_WORK_CNT), 0, NULL, MAX(F.YYYYMM_WORK_CNT))  AS ${item.COL_ID}
                    </when>
                    <when test="item.COL_GUBUN != null and item.COL_GUBUN eq 'ITEM-PRDT-TOTAL_PRDT_QTY'.toString()">
         , SUM(CASE WHEN E.ITEM_CODE = #{item.ITEM_CODE, jdbcType=VARCHAR} THEN NVL(E.PRDT_QTY, 0) ELSE 0 END)                                                                       AS ${item.COL_ID}
                    </when>
                    <when test="item.COL_GUBUN != null and item.COL_GUBUN eq 'ITEM-PRDT-LINE-PRDT_QTY'.toString()">
         , SUM(CASE WHEN E.ITEM_CODE = #{item.ITEM_CODE, jdbcType=VARCHAR} AND E.ORG_CODE = #{item.ORG_CODE, jdbcType=VARCHAR} AND E.LINE_DEPT_CODE = #{item.LINE_DEPT_CODE, jdbcType=VARCHAR} THEN NVL(E.PRDT_QTY, 0) ELSE 0 END)                  AS ${item.COL_ID}
                    </when>
                    <when test="item.COL_GUBUN != null and item.COL_GUBUN eq 'ITEM-PRDT-LINE-USE_HR'.toString()">
         , SUM(CASE WHEN E.ITEM_CODE = #{item.ITEM_CODE, jdbcType=VARCHAR} AND E.ORG_CODE = #{item.ORG_CODE, jdbcType=VARCHAR} AND E.LINE_DEPT_CODE = #{item.LINE_DEPT_CODE, jdbcType=VARCHAR} THEN NVL(E.USE_HR, 0) ELSE 0 END)                    AS ${item.COL_ID}
                    </when>
                    <when test="item.COL_GUBUN != null and item.COL_GUBUN eq 'ITEM-STOCK_QTY'.toString()">
         , SUM(CASE WHEN E.ITEM_CODE = #{item.ITEM_CODE, jdbcType=VARCHAR} THEN NVL(E.STOCK_QTY, 0) ELSE 0 END)                                                                      AS ${item.COL_ID}
                    </when>
                    <when test="item.COL_GUBUN != null and item.COL_GUBUN eq 'ITEM-STOCK_DCNT'.toString()">
         , CASE WHEN SUM(CASE WHEN E.ITEM_CODE = #{item.ITEM_CODE, jdbcType=VARCHAR} THEN NVL(E.MM_SALE_QTY, 0) ELSE 0 END) = 0 THEN NULL
                ELSE SUM(CASE WHEN E.ITEM_CODE = #{item.ITEM_CODE, jdbcType=VARCHAR} THEN NVL(E.STOCK_QTY, 0) ELSE 0 END) / SUM(CASE WHEN E.ITEM_CODE = #{item.ITEM_CODE, jdbcType=VARCHAR} THEN NVL(E.MM_SALE_QTY, 0) ELSE 0 END) * MAX(F.YYYYMM_WORK_CNT)
           END                                                                                                                                                                       AS ${item.COL_ID}
                    </when>
                    <when test="item.COL_GUBUN != null and item.COL_GUBUN eq 'CHECK_PRDT_HR-LINE-AVL_HR'.toString()">
         , MAX(CASE WHEN E.ITEM_CODE = '-' AND E.ORG_CODE = #{item.ORG_CODE, jdbcType=VARCHAR} AND E.LINE_DEPT_CODE = #{item.LINE_DEPT_CODE, jdbcType=VARCHAR} THEN NVL(E.AVL_HR, 0) ELSE 0 END)                           AS ${item.COL_ID}
                    </when>
                    <when test="item.COL_GUBUN != null and item.COL_GUBUN eq 'CHECK_PRDT_HR-LINE-USE_HR'.toString()">
         , SUM(CASE WHEN                       E.ORG_CODE = #{item.ORG_CODE, jdbcType=VARCHAR} AND E.LINE_DEPT_CODE = #{item.LINE_DEPT_CODE, jdbcType=VARCHAR} THEN NVL(E.USE_HR, 0) ELSE 0 END)                           AS ${item.COL_ID}
                    </when>
                    <otherwise></otherwise>
                </choose>
            </foreach>
        </if>
        
      FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_M       A
      JOIN EDW.W_CM_TB_LIQUOR_M                 B
        ON B.LIQUOR_CODE = #{liquorCode, jdbcType=VARCHAR}
 LEFT JOIN (    -- D. 버전의 유효기간에 해당하는 날짜 리스트(월, 연주차, 일자)
                SELECT DB.VER_CD, DC.PERIOD_TYPE
                     , CASE WHEN DC.PERIOD_TYPE = 'YYYYMM'   THEN DA.YYYYMM
                            WHEN DC.PERIOD_TYPE = 'YYYYWW'   THEN DA.SCM_YYYYWW
                            WHEN DC.PERIOD_TYPE = 'YYYYMMDD' THEN DA.YYYYMMDD
                       END                  AS PERIOD_CODE
                     , CASE WHEN DC.PERIOD_TYPE = 'YYYYMM'   THEN MAX( SUBSTR(DA.YYYYMM, 1, 4) || '-' || SUBSTR(DA.YYYYMM, 5, 2) || '월' )
                            WHEN DC.PERIOD_TYPE = 'YYYYWW'   THEN MAX( SUBSTR(DA.SCM_YYYYWW, 1, 4) || '년 ' || SUBSTR(DA.SCM_YYYYWW, 5, 2) || '주차' ) || '(' || MIN(TO_CHAR(TO_DATE(DA.YYYYMMDD, 'YYYYMMDD'), 'MM/DD')) || '~' || MAX(TO_CHAR(TO_DATE(DA.YYYYMMDD, 'YYYYMMDD'), 'MM/DD')) || ')'
                            WHEN DC.PERIOD_TYPE = 'YYYYMMDD' THEN MAX( TO_CHAR(TO_DATE(DA.YYYYMMDD, 'YYYYMMDD'), 'YYYY-MM-DD') || ' (' || DA.DAY_OF_WEEK_DESC || ')' )
                       END                  AS PERIOD_NAME
                     , CASE WHEN DC.PERIOD_TYPE = 'YYYYMM'   THEN TO_CHAR(NULL)
                            WHEN DC.PERIOD_TYPE = 'YYYYWW'   THEN TO_CHAR(NULL)
                            WHEN DC.PERIOD_TYPE = 'YYYYMMDD' THEN MAX(DA.BUSINESS_DAY_FLAG)
                       END                  AS BUSINESS_DAY_FLAG
                     , MIN(DA.YYYYMMDD)     AS PERIOD_FR_YYYYMMDD
                     , MAX(DA.YYYYMMDD)     AS PERIOD_TO_YYYYMMDD
                     , MAX(DC.SEQ)          AS PERIOD_TYPE_SEQ
                     , CASE WHEN DC.PERIOD_TYPE = 'YYYYMM'   THEN MAX( DA.YYYYMM_WORK_CNT )
                            WHEN DC.PERIOD_TYPE = 'YYYYWW'   THEN MAX( DA.SCM_YYYYWW_WORK_CNT )
                            WHEN DC.PERIOD_TYPE = 'YYYYMMDD' THEN 1
                       END                  AS CALENDAR_WORK_CNT -- 기간의 영업일수 : 실제 달력상의 영업일수(월의 시작/종료 주차에서 일자가 잘려도 무시 )
                     , SUM(CASE WHEN DA.BUSINESS_DAY_FLAG = 'Y' THEN 1 ELSE 0 END) AS WORK_CNT -- 기간의 영업일수 : 월의 시작/종료 주차의 경우, 해당 월에 포함된 날짜만 계산
                     , MAX( DA.YYYYMM_WORK_CNT )    AS CALENDAR_MM_WORK_CNT -- 월의 영업일수
                     
                  FROM SCMU.W_SOP_VW_CALENDAR_M       DA
                  JOIN SCMU.W_SOP_TB_DALY_SCM_SIMUL_M DB
                    ON DA.YYYYMMDD BETWEEN DB.VER_FR_DT AND DB.VER_TO_DT
            CROSS JOIN (
                            SELECT 'YYYYMM'   AS PERIOD_TYPE, 1 AS SEQ FROM DUAL UNION ALL
                            SELECT 'YYYYWW'   AS PERIOD_TYPE, 2 AS SEQ FROM DUAL UNION ALL
                            SELECT 'YYYYMMDD' AS PERIOD_TYPE, 3 AS SEQ FROM DUAL
                       )                              DC
                 WHERE 1 = 1
                   AND DB.VER_CD = #{verCd, jdbcType=VARCHAR}
                 GROUP BY DB.VER_CD, DC.PERIOD_TYPE
                        , CASE WHEN DC.PERIOD_TYPE = 'YYYYMM'   THEN DA.YYYYMM
                               WHEN DC.PERIOD_TYPE = 'YYYYWW'   THEN DA.SCM_YYYYWW
                               WHEN DC.PERIOD_TYPE = 'YYYYMMDD' THEN DA.YYYYMMDD
                          END
           )                                    D
        ON D.VER_CD = A.VER_CD
                -- E. 판매량, 월별 판매량, 공장/라인의 생산량/사용시간, 재고량, 공장/라인의 가용시간
 LEFT JOIN RESULT_TBL                           E
        ON E.VER_CD      = A.VER_CD
       AND E.PERIOD_TYPE = D.PERIOD_TYPE
       AND E.PERIOD_CODE = D.PERIOD_CODE
                -- F. 달력 : 월간 영업일수 체크용(일평균판매량 = 월별판매량 / 월간영업일수)
 LEFT JOIN SCMU.W_SOP_VW_CALENDAR_M             F
        ON F.YYYYMMDD = D.PERIOD_FR_YYYYMMDD -- 주가 2개월에 걸쳐있을때, 주의 시작일에 해당하는 월 기준(시뮬레이션 로직과 동일)
     WHERE 1 = 1
       AND A.VER_CD = #{verCd, jdbcType=VARCHAR}
     GROUP BY A.VER_CD, A.STD_YYYYMMDD, B.LIQUOR_CODE, B.LIQUOR_DESC, D.PERIOD_TYPE, D.PERIOD_CODE, D.PERIOD_NAME, D.BUSINESS_DAY_FLAG, D.PERIOD_FR_YYYYMMDD, D.PERIOD_TO_YYYYMMDD, D.PERIOD_TYPE_SEQ
     ORDER BY B.LIQUOR_CODE, D.PERIOD_FR_YYYYMMDD, D.PERIOD_TYPE_SEQ, D.PERIOD_CODE
    </select>
    
    <!-- 시뮬레이션 프로시저 호출 -->
    <update id="callDalyScmSimul" parameterType="hashmap"     statementType="CALLABLE">
        {  CALL /* com.hitejinro.snop.work.dao.M02020DaoMapper.callDalyScmSimul */
                SCMU.PKG_SOP_DALY_SCM_SIMUL.SP_MAIN_DALY_SCM_SIMUL_F
                (
                      P_VER_CD          => #{verCd               , mode=IN,jdbcType=VARCHAR}
                    , P_LIQUOR_CODE     => #{liquorCode          , mode=IN,jdbcType=VARCHAR}
                    , P_WORKFLOW        => TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS')
                    , P_USER_NO         => #{userId              , mode=IN,jdbcType=VARCHAR}
                    , O_TOT_ROWCOUNT    => #{O_TOT_ROWCOUNT      , mode=OUT,jdbcType=NUMERIC}    -- 실행 결과 건수
                    , O_RETURN_MSG      => #{O_RETURN_MSG        , mode=OUT,jdbcType=VARCHAR}    -- 실행 결과 메시지. 오류일때 반환
                    , O_RETURN_STATUS   => #{O_RETURN_STATUS     , mode=OUT,jdbcType=VARCHAR}    -- 실행 결과 상태 : S(성공), F(실패)
                )
        }
    </update>
    
    <!-- 재고계산 프로시저 호출 : 특정 주차로 계산하기 어려우니, 전체 계획기간으로 재계산 -->
    <update id="callCalcStock" parameterType="hashmap"     statementType="CALLABLE">
        {  CALL /* com.hitejinro.snop.work.dao.M02020DaoMapper.callCalcStock */
                SCMU.PKG_SOP_DALY_SCM_SIMUL.SP_CALC_STOCK_DALY_SCM_SIMUL_F
                (
                      P_VER_CD          => #{verCd               , mode=IN,jdbcType=VARCHAR}
                    , P_LIQUOR_CODE     => #{liquorCode          , mode=IN,jdbcType=VARCHAR}
                    , P_FR_SCM_YYYYWW   => NULL                                                  -- 재고계산 시작주차(계획기간만 가능) : 비어있으면, 계획기간 시작주차
                    , P_TO_SCM_YYYYWW   => NULL                                                  -- 재고계산 종료주차(계획기간만 가능) : 비어있으면, 계획기간 종료주차
                    , P_WORKFLOW        => TO_CHAR(SYSDATE, 'YYYYMMDDHH24MISS')
                    , P_USER_NO         => #{userId              , mode=IN,jdbcType=VARCHAR}
                    , O_TOT_ROWCOUNT    => #{O_TOT_ROWCOUNT      , mode=OUT,jdbcType=NUMERIC}    -- 실행 결과 건수
                    , O_RETURN_MSG      => #{O_RETURN_MSG        , mode=OUT,jdbcType=VARCHAR}    -- 실행 결과 메시지. 오류일때 반환
                    , O_RETURN_STATUS   => #{O_RETURN_STATUS     , mode=OUT,jdbcType=VARCHAR}    -- 실행 결과 상태 : S(성공), F(실패)
                )
        }
    </update>
    
    <!-- 결과설정 데이터 저장 : 제품/공장/라인의 일자별 생산량/사용시간 저장(생산량을 기준으로 사용시간 역산) -->
    <update id="updateResult" parameterType="map">
MERGE /* com.hitejinro.snop.work.dao.M02020DaoMapper.updateResult */
 INTO SCMU.W_SOP_TB_DALY_SCM_SIMUL_RESULT_F T
USING (
            SELECT SA.VER_CD, SA.LIQUOR_CODE, SA.ORG_CODE, SA.LINE_DEPT_CODE, SA.PERIOD_CODE AS PERIOD_YYYYMMDD, SA.ITEM_CODE
                 , CASE WHEN NVL(SD.QTY_PER_HOUR, 0) * NVL(SD.PRDT_EFC_RATE, 1) = 0 THEN TO_NUMBER(NULL)
                        ELSE                                                             NVL(SA.PRDT_QTY / ( NVL(SD.QTY_PER_HOUR, 0) * NVL(SD.PRDT_EFC_RATE, 1) ), 0)
                   END      AS USE_HR
                 , CASE WHEN NVL(SD.QTY_PER_HOUR, 0) * NVL(SD.PRDT_EFC_RATE, 1) = 0 THEN TO_NUMBER(NULL)
                        ELSE                                                             SA.PRDT_QTY
                   END      AS PRDT_QTY
                 , NVL(SD.LINE_DEPT_NAME, SE.LINE_DEPT_NAME) AS LINE_DEPT_NAME, SD.QTY_PER_HOUR, SD.PRDT_EFC_RATE
                 , TO_NUMBER(NULL) AS STOCK_QTY, TO_NUMBER(NULL) AS SAFT_STOCK_DCNT, TO_NUMBER(NULL) AS MIN_PRDT_QTY, TO_NUMBER(NULL) AS PRDT_RANK -- 재고관련 데이터는 공장/라인="-" 데이터용
                 , 'N' AS ACTUAL_YN, SB.SCM_YYYYWW AS PERIOD_SCM_YYYYWW, 'Y' AS MODIFY_YN
                 , NULL AS ATTRIBUTE1, NULL AS ATTRIBUTE2, NULL AS ATTRIBUTE3, NULL AS ATTRIBUTE4, NULL AS ATTRIBUTE5
              FROM (
        <foreach collection="updateList" item="list" separator="UNION ALL" index="i">
SELECT #{list.VER_CD, jdbcType=VARCHAR}                                                                     AS VER_CD
     , #{list.LIQUOR_CODE, jdbcType=VARCHAR}                                                                AS LIQUOR_CODE
     , #{list.PERIOD_TYPE, jdbcType=VARCHAR}                                                                AS PERIOD_TYPE
     , #{list.PERIOD_CODE, jdbcType=VARCHAR}                                                                AS PERIOD_CODE
     , #{list.ITEM_CODE, jdbcType=VARCHAR}                                                                  AS ITEM_CODE
     , #{list.ORG_CODE, jdbcType=VARCHAR}                                                                   AS ORG_CODE
     , #{list.LINE_DEPT_CODE, jdbcType=VARCHAR}                                                             AS LINE_DEPT_CODE
     , NVL(TO_NUMBER(#{list.PRDT_QTY, jdbcType=VARCHAR}), 0)                                                AS PRDT_QTY
     
     , #{list.action, jdbcType=VARCHAR}                                                                     AS ROW_ACTION   -- 행 상태 : insert, update, delete
     , ROWNUM                                                                                               AS RNUM
  FROM DUAL
        </foreach>
                   )                                    SA
         LEFT JOIN SCMU.W_SOP_VW_CALENDAR_M             SB
                ON SB.YYYYMMDD = SA.PERIOD_CODE
              JOIN SCMU.W_SOP_TB_DALY_SCM_SIMUL_M       SC
                ON SC.VER_CD = SA.VER_CD
         LEFT JOIN SCMU.W_SOP_TB_PRDT_VAR_DTL_M         SD
                ON SD.PRDT_VAR_VER_CD = SC.PRDT_VAR_VER_CD
               AND SD.ORG_CODE        = SA.ORG_CODE
               AND SD.LINE_DEPT_CODE  = SA.LINE_DEPT_CODE
               AND SD.ITEM_CODE       = SA.ITEM_CODE
         LEFT JOIN (    -- SE. 공장/라인의 명칭 : 간혹 생산변수에 정의되지 않은 라인의 명칭 때문에
                        SELECT VER_CD, LIQUOR_CODE, ORG_CODE, LINE_DEPT_CODE
                             , MAX(LINE_DEPT_NAME) AS LINE_DEPT_NAME
                          FROM SCMU.W_SOP_TB_DALY_SCM_SIMUL_PRDT_F
                         WHERE 1 = 1
                         GROUP BY VER_CD, LIQUOR_CODE, ORG_CODE, LINE_DEPT_CODE
                   )                          SE
                ON SE.VER_CD         = SA.VER_CD
               AND SE.LIQUOR_CODE    = SA.LIQUOR_CODE
               AND SE.ORG_CODE       = SA.ORG_CODE
               AND SE.LINE_DEPT_CODE = SA.LINE_DEPT_CODE
             WHERE 1 = 1
      ) S
   ON (T.VER_CD = S.VER_CD AND T.LIQUOR_CODE = S.LIQUOR_CODE AND T.ORG_CODE = S.ORG_CODE AND T.LINE_DEPT_CODE = S.LINE_DEPT_CODE AND T.PERIOD_YYYYMMDD = S.PERIOD_YYYYMMDD AND T.ITEM_CODE = S.ITEM_CODE)
 WHEN MATCHED THEN
    UPDATE
       SET T.USE_HR             = S.USE_HR
         , T.PRDT_QTY           = S.PRDT_QTY
         , T.MODIFY_YN          = S.MODIFY_YN   -- Y로 고정
         , T.RMKS               = T.RMKS || ' => ' || '수기입력(USE_HR=' || TRIM(TO_CHAR(S.USE_HR, '9,999,999,999.9')) || ', PRDT_QTY=' || TRIM(TO_CHAR(S.PRDT_QTY, '9,999,999,999.9')) || ')' -- 수기변경값 표현
         , T.LAST_UPDATED_BY    = #{userId, jdbcType=VARCHAR}
         , T.LAST_UPDATE_DATE   = SYSDATE
 
 WHEN NOT MATCHED THEN
    INSERT (T.VER_CD, T.LIQUOR_CODE, T.ORG_CODE, T.LINE_DEPT_CODE, T.PERIOD_YYYYMMDD, T.ITEM_CODE
            , T.USE_HR, T.PRDT_QTY, T.CALC_USE_HR, T.CALC_PRDT_QTY, T.LINE_DEPT_NAME, T.QTY_PER_HOUR, T.PRDT_EFC_RATE
            , T.STOCK_QTY, T.SAFT_STOCK_DCNT, T.MIN_PRDT_QTY, T.PRDT_RANK, T.ACTUAL_YN, T.PERIOD_SCM_YYYYWW, T.MODIFY_YN
            , T.RMKS
            , T.ATTRIBUTE1, T.ATTRIBUTE2, T.ATTRIBUTE3, T.ATTRIBUTE4, T.ATTRIBUTE5, T.CREATED_BY, T.CREATION_DATE, T.LAST_UPDATED_BY, T.LAST_UPDATE_DATE)
    VALUES (S.VER_CD, S.LIQUOR_CODE, S.ORG_CODE, S.LINE_DEPT_CODE, S.PERIOD_YYYYMMDD, S.ITEM_CODE
            , S.USE_HR, S.PRDT_QTY, TO_NUMBER(NULL), TO_NUMBER(NULL), S.LINE_DEPT_NAME, S.QTY_PER_HOUR, S.PRDT_EFC_RATE
            , S.STOCK_QTY, S.SAFT_STOCK_DCNT, S.MIN_PRDT_QTY, S.PRDT_RANK, S.ACTUAL_YN, S.PERIOD_SCM_YYYYWW, S.MODIFY_YN
            , '수기입력(USE_HR=' || TRIM(TO_CHAR(S.USE_HR, '9,999,999,999.9')) || ', PRDT_QTY=' || TRIM(TO_CHAR(S.PRDT_QTY, '9,999,999,999.9')) || ')'
            , S.ATTRIBUTE1, S.ATTRIBUTE2, S.ATTRIBUTE3, S.ATTRIBUTE4, S.ATTRIBUTE5, #{userId, jdbcType=VARCHAR}, SYSDATE, #{userId, jdbcType=VARCHAR}, SYSDATE)
    </update>


</mapper>